[{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\add_webhook_provider_columns.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\apply_migrations.js","messages":[{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":33,"column":55,"nodeType":"BlockStatement","messageId":"unexpected","endLine":33,"endColumn":57,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[1135,1135],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\nimport fs from 'fs';\r\nimport path from 'path';\r\nimport pkg from 'pg';\r\nconst { Pool } = pkg;\r\n\r\nasync function run() {\r\n  const databaseUrl = process.env.DATABASE_URL;\r\n  if (!databaseUrl) {\r\n    console.error('Please set DATABASE_URL env var (postgres connection string)');\r\n    process.exit(2);\r\n  }\r\n\r\n  const pool = new Pool({ connectionString: databaseUrl });\r\n  const client = await pool.connect();\r\n  try {\r\n    const migrationsDir = path.join(process.cwd(), 'migrations');\r\n    const files = ['001_create_users_payments.sql', '002_create_webhooks.sql'];\r\n    console.log('Applying migrations:', files.join(', '));\r\n    await client.query('BEGIN');\r\n    for (const f of files) {\r\n      const p = path.join(migrationsDir, f);\r\n      if (!fs.existsSync(p)) {\r\n        throw new Error('Missing migration file: ' + p);\r\n      }\r\n      const sql = fs.readFileSync(p, 'utf8');\r\n      console.log('Running', f);\r\n      await client.query(sql);\r\n    }\r\n    await client.query('COMMIT');\r\n    console.log('Migrations applied successfully');\r\n  } catch (err) {\r\n    try { await client.query('ROLLBACK'); } catch (e) {}\r\n    console.error('Migration failed:', err && err.message ? err.message : err);\r\n    process.exitCode = 1;\r\n  } finally {\r\n    client.release();\r\n    await pool.end();\r\n  }\r\n}\r\n\r\nrun().catch(err => { console.error(err); process.exit(1); });\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\azure-discover.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\build-static.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\check-live-health.js","messages":[{"ruleId":"import/no-named-as-default","severity":1,"message":"Using exported name 'SportsAggregator' as identifier for default import.","line":5,"column":8,"nodeType":"ImportDefaultSpecifier","endLine":5,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n// Quick script to check API-Sports (primary) health via SportsAggregator\r\n// Usage: set your env vars (API keys) and run: node ./scripts/check-live-health.js\r\n\r\nimport SportsAggregator from '../src/services/sports-aggregator.js';\r\n\r\n(async () => {\r\n  try {\r\n    const agg = new SportsAggregator(null, {});\r\n    const r = await agg.checkPrimaryProviderHealth();\r\n    console.log('Primary provider health:', r);\r\n    const healthy = await agg.isLiveFeedHealthy();\r\n    console.log('isLiveFeedHealthy():', healthy);\r\n    process.exit(0);\r\n  } catch (e) {\r\n    console.error('Health check failed:', e);\r\n    process.exit(2);\r\n  }\r\n})();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\check-providers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\check_connections.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\check_syntax.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\create_lipana_stk.js","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected character '!'","line":92,"column":2,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\nimport fetch from 'node-fetch';\r\nimport crypto from 'crypto';\r\n\r\n// Usage: set env LIPANA_API_KEY and optionally LIPANA_API_BASE, ENDPOINT_PHONE\r\nconst API_BASE = process.env.LIPANA_API_BASE || 'https://api.lipana.dev';\r\nconst KEY = process.env.LIPANA_API_KEY;\r\nconst CALLBACK = process.env.LIPANA_CALLBACK_URL || 'https://betrix-ui.onrender.com/webhook/mpesa';\r\nconst PHONE = process.argv[2] || process.env.ENDPOINT_PHONE || '+254720798611';\r\nconst AMOUNT = Number(process.argv[3] || process.env.AMOUNT || 300);\r\nconst CURRENCY = process.env.CURRENCY || 'KES';\r\n\r\nif (!KEY) {\r\n  console.error('LIPANA_API_KEY required in env');\r\n  process.exit(2);\r\n}\r\n\r\nfunction makeRef() {\r\n  return `betrix_stk_${Date.now()}_${Math.random().toString(36).slice(2,8)}`;\r\n}\r\n\r\nasync function createTransaction({ phone, amount, currency, reference, callback }){\r\n  const url = `${API_BASE.replace(/\\/$/, '')}/v1/transactions`;\r\n  const body = {\r\n    amount,\r\n    currency,\r\n    phone,\r\n    type: 'stk_push',\r\n    reference,\r\n    callback_url: callback,\r\n    description: `BETRIX KES ${amount} STK push`,\r\n  };\r\n\r\n  const res = await fetch(url, {\r\n    method: 'POST',\r\n    headers: {\r\n      'content-type': 'application/json',\r\n      'x-api-key': KEY,\r\n    },\r\n    body: JSON.stringify(body),\r\n    timeout: 15000,\r\n  });\r\n\r\n  const j = await res.json().catch(() => null);\r\n  return { status: res.status, ok: res.ok, body: j };\r\n}\r\n\r\nasync function queryByReference(reference){\r\n  const url = `${API_BASE.replace(/\\/$/, '')}/v1/transactions?reference=${encodeURIComponent(reference)}`;\r\n  const res = await fetch(url, { headers: { 'x-api-key': KEY }, timeout: 10000 });\r\n  const j = await res.json().catch(() => null);\r\n  return { status: res.status, body: j };\r\n}\r\n\r\n(async function main(){\r\n  const reference = makeRef();\r\n  console.log('Creating STK push', { phone: PHONE, amount: AMOUNT, currency: CURRENCY, reference, callback: CALLBACK });\r\n  try{\r\n    const created = await createTransaction({ phone: PHONE, amount: AMOUNT, currency: CURRENCY, reference, callback: CALLBACK });\r\n    console.log('Create response:', created.status, JSON.stringify(created.body || created, null, 2));\r\n\r\n    if (!created.ok) {\r\n      console.error('Create failed; aborting poll.');\r\n      process.exit(1);\r\n    }\r\n\r\n    console.log('Polling Lipana for transaction status... (timeout 120s)');\r\n    const deadline = Date.now() + 120000;\r\n    let last = null;\r\n    while (Date.now() < deadline) {\r\n      const q = await queryByReference(reference);\r\n      const rows = q.body && q.body.data ? q.body.data : null;\r\n      const item = rows && rows.length ? rows[0] : null;\r\n      const status = item && (item.status || item.state) ? (item.status || item.state) : null;\r\n      if (JSON.stringify(item) !== JSON.stringify(last)) {\r\n        console.log('Polled:', new Date().toISOString(), 'status=', status, 'item=', JSON.stringify(item || q.body || {}, null, 2));\r\n        last = item || q.body;\r\n      }\r\n      if (status && ['success','failed','timeout','cancelled'].includes(String(status).toLowerCase())){\r\n        console.log('Terminal status reached:', status);\r\n        process.exit(0);\r\n      }\r\n      await new Promise(r => setTimeout(r, 5000));\r\n    }\r\n    console.log('Polling timed out, last seen:', JSON.stringify(last || {}, null, 2));\r\n    process.exit(0);\r\n  }catch(err){\r\n    console.error('Fatal error', err && err.message || err);\r\n    process.exit(2);\r\n  }\r\n})();\r\n#!/usr/bin/env node\r\nimport fetch from 'node-fetch';\r\n\r\nconst API_BASE = process.env.LIPANA_API_BASE || 'https://api.lipana.dev';\r\nconst KEY = process.argv[2] || process.env.LIPANA_API_KEY;\r\nconst PHONE = process.argv[3] || process.env.TO_PHONE || '+254720798611';\r\nconst AMOUNT = Number(process.argv[4] || process.env.AMOUNT || 300);\r\nconst CALLBACK = process.argv[5] || process.env.CALLBACK_URL || 'https://betrix-ui.onrender.com/webhook/mpesa';\r\n\r\nif (!KEY) {\r\n  console.error('LIPANA_API_KEY required as argv[1] or LIPANA_API_KEY env');\r\n  process.exit(2);\r\n}\r\n\r\nasync function createStk() {\r\n  const url = `${API_BASE}/v1/transactions`;\r\n  const body = {\r\n    amount: AMOUNT,\r\n    currency: 'KES',\r\n    phone: PHONE,\r\n    reference: `betrix_test_${Date.now()}`,\r\n    provider: 'lipana',\r\n    callback_url: CALLBACK,\r\n    description: 'BETRIX KES 300 STK test'\r\n  };\r\n\r\n  console.log('POST', url);\r\n  console.log('BODY', body);\r\n\r\n  try {\r\n    const res = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'x-api-key': KEY\r\n      },\r\n      body: JSON.stringify(body),\r\n      timeout: 15000\r\n    });\r\n    const text = await res.text();\r\n    let json = null;\r\n    try { json = JSON.parse(text); } catch(e) { json = null; }\r\n    console.log('STATUS', res.status, res.statusText);\r\n    console.log('HEADERS', res.headers.raw ? res.headers.raw() : {});\r\n    console.log('BODY', json || text);\r\n    if (res.ok) return json;\r\n    throw new Error(`Non-OK response ${res.status}`);\r\n  } catch (err) {\r\n    console.error('Error creating STK', err && err.message);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\ncreateStk().then((j) => { console.log('Done', j); process.exit(0); }).catch(e => { console.error(e); process.exit(1); });\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\create_lipana_stk_fix.js","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":8,"column":15,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\nimport fetch from 'node-fetch';\r\n\r\n// Fixed STK creation + poll script for Lipana\r\n// Usage: set env LIPANA_API_KEY and optionally LIPANA_API_BASE, LIPANA_callback: \"https://betrix-ui.onrender.com/webhook/mpesa\",`n  payoutAccount: process.env.PAYOUT_ACCOUNT || \"6062105\"\r\nconst API_BASE = process.env.LIPANA_API_BASE || 'https://api.lipana.dev';\r\nconst KEY = process.env.LIPANA_API_KEY;\r\nconst callback: \"https://betrix-ui.onrender.com/webhook/mpesa\",`n  payoutAccount: process.env.PAYOUT_ACCOUNT || \"6062105\"\r\nconst PHONE = process.argv[2] || process.env.ENDPOINT_PHONE || '+254720798611';\r\nconst AMOUNT = Number(process.argv[3] || process.env.AMOUNT || 300);\r\nconst CURRENCY = process.env.CURRENCY || 'KES';\r\n\r\nif (!KEY) {\r\n  console.error('LIPANA_API_KEY required in env');\r\n  process.exit(2);\r\n}\r\n\r\nfunction makeRef() {\r\n  return `betrix_stk_${Date.now()}_${Math.random().toString(36).slice(2,8)}`;\r\n}\r\n\r\nasync function createTransaction({ phone, amount, currency, reference, callback: \"https://betrix-ui.onrender.com/webhook/mpesa\",`n  payoutAccount: process.env.PAYOUT_ACCOUNT || \"6062105\"\r\n  const url = `${API_BASE.replace(/\\/$/, '')}/v1/transactions`;\r\n  const body = {\r\n    amount,\r\n    currency,\r\n    phone,\r\n    type: 'stk_push',\r\n    reference,\r\n    callback: \"https://betrix-ui.onrender.com/webhook/mpesa\",`n  payoutAccount: process.env.PAYOUT_ACCOUNT || \"6062105\"\r\n    description: `BETRIX KES ${amount} STK push`,\r\n  };\r\n\r\n  const res = await fetch(url, {\r\n    method: 'POST',\r\n    headers: {\r\n      'content-type': 'application/json',\r\n      'x-api-key': KEY,\r\n    },\r\n    body: JSON.stringify(body),\r\n    timeout: 15000,\r\n  });\r\n\r\n  const j = await res.json().catch(() => null);\r\n  return { status: res.status, ok: res.ok, body: j };\r\n}\r\n\r\nasync function queryByReference(reference){\r\n  const url = `${API_BASE.replace(/\\/$/, '')}/v1/transactions?reference=${encodeURIComponent(reference)}`;\r\n  const res = await fetch(url, { headers: { 'x-api-key': KEY }, timeout: 10000 });\r\n  const j = await res.json().catch(() => null);\r\n  return { status: res.status, body: j };\r\n}\r\n\r\n(async function main(){\r\n  const reference = makeRef();\r\n  console.log('Creating STK push', { phone: PHONE, amount: AMOUNT, currency: CURRENCY, reference, callback: \"https://betrix-ui.onrender.com/webhook/mpesa\",`n  payoutAccount: process.env.PAYOUT_ACCOUNT || \"6062105\"\r\n  try{\r\n    const created = await createTransaction({ phone: PHONE, amount: AMOUNT, currency: CURRENCY, reference, callback: \"https://betrix-ui.onrender.com/webhook/mpesa\",`n  payoutAccount: process.env.PAYOUT_ACCOUNT || \"6062105\"\r\n    console.log('Create response:', created.status, JSON.stringify(created.body || created, null, 2));\r\n\r\n    if (!created.ok) {\r\n      console.error('Create failed; aborting poll.');\r\n      process.exit(1);\r\n    }\r\n\r\n    console.log('Polling Lipana for transaction status... (timeout 120s)');\r\n    const deadline = Date.now() + 120000;\r\n    let last = null;\r\n    while (Date.now() < deadline) {\r\n      const q = await queryByReference(reference);\r\n      const rows = q.body && q.body.data ? q.body.data : null;\r\n      const item = rows && rows.length ? rows[0] : null;\r\n      const status = item && (item.status || item.state) ? (item.status || item.state) : null;\r\n      if (JSON.stringify(item) !== JSON.stringify(last)) {\r\n        console.log('Polled:', new Date().toISOString(), 'status=', status, 'item=', JSON.stringify(item || q.body || {}, null, 2));\r\n        last = item || q.body;\r\n      }\r\n      if (status && ['success','failed','timeout','cancelled'].includes(String(status).toLowerCase())){\r\n        console.log('Terminal status reached:', status);\r\n        process.exit(0);\r\n      }\r\n      await new Promise(r => setTimeout(r, 5000));\r\n    }\r\n    console.log('Polling timed out, last seen:', JSON.stringify(last || {}, null, 2));\r\n    process.exit(0);\r\n  }catch(err){\r\n    console.error('Fatal error', err && err.message || err);\r\n    process.exit(2);\r\n  }\r\n})();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\create_test_user.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\debug_lipana_raw.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\debug_sendpayload.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\dump_payments_json.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\dump_webhooks_json.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\e2e-callbacks.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'id' is defined but never used.","line":28,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":28,"endColumn":41}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n/*\r\n  E2E Callback simulator: runs a sequence of callback_query payloads\r\n  against the v2 callback handler and prints returned action objects.\r\n  This runs locally using a MockRedis to avoid touching production services.\r\n*/\r\n\r\nprocess.env.USE_MOCK_REDIS = process.env.USE_MOCK_REDIS || '1';\r\n\r\nclass MockRedis {\r\n  constructor() { this.store = new Map(); this.hashes = new Map(); }\r\n  async get(k){ return this.store.has(k)?this.store.get(k):null; }\r\n  async set(k,v){ this.store.set(k,String(v)); return 'OK'; }\r\n  async setex(k,ttl,v){ this.store.set(k,String(v)); return 'OK'; }\r\n  async hgetall(k){ return this.hashes.get(k) || {}; }\r\n  async hset(hash, field, val){ const h = this.hashes.get(hash) || {}; h[field]=String(val); this.hashes.set(hash,h); return 1; }\r\n  async rpush(k,v){ const arr = this.store.get(k)?JSON.parse(this.store.get(k)):[]; arr.push(v); this.store.set(k,JSON.stringify(arr)); return arr.length; }\r\n}\r\n\r\nasync function run() {\r\n  const { handleCallbackQuery } = await import('../src/handlers/telegram-handler-v2.js');\r\n  const redis = new MockRedis();\r\n\r\n  const services = {\r\n    openLiga: { getRecentMatches: async () => [] },\r\n    footballData: { fixturesFromCsv: async () => ({ fixtures: [] }) },\r\n    rss: { fetchMultiple: async () => [] },\r\n    apiFootball: { getFixture: async (id) => ({ response: [] }) }\r\n  };\r\n\r\n  const callbacks = [\r\n    { id: 'cb-menu', from: { id: 424242 }, message: { chat: { id: 9999, message_id: 1 } }, data: 'menu_main' },\r\n    { id: 'cb-live', from: { id: 424242 }, message: { chat: { id: 9999, message_id: 2 } }, data: 'menu_live' },\r\n    { id: 'cb-sport', from: { id: 424242 }, message: { chat: { id: 9999, message_id: 3 } }, data: 'sport_football' },\r\n    { id: 'cb-league', from: { id: 424242 }, message: { chat: { id: 9999, message_id: 4 } }, data: 'league_39' },\r\n    { id: 'cb-standings', from: { id: 424242 }, message: { chat: { id: 9999, message_id: 5 } }, data: 'league_standings_39' },\r\n    { id: 'cb-odds', from: { id: 424242 }, message: { chat: { id: 9999, message_id: 6 } }, data: 'menu_odds' }\r\n  ];\r\n\r\n  for (const cb of callbacks) {\r\n    console.log('\\n--- Simulating callback:', cb.data, '---');\r\n    try {\r\n      const res = await handleCallbackQuery(cb, redis, services);\r\n      console.log('Returned:', JSON.stringify(res, null, 2));\r\n    } catch (e) {\r\n      console.error('Handler error for', cb.data, e && e.message || e);\r\n    }\r\n  }\r\n}\r\n\r\nrun().catch(e=>{ console.error('e2e-callbacks error', e); process.exit(1);} );\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\e2e-payment-harness.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\e2e-payments-test.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'key' is defined but never used.","line":35,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":35,"endColumn":19},{"ruleId":"no-unused-vars","severity":2,"message":"'ttl' is defined but never used.","line":35,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":35,"endColumn":24},{"ruleId":"no-unused-vars","severity":2,"message":"'key' is defined but never used.","line":36,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":36,"endColumn":16},{"ruleId":"import/namespace","severity":2,"message":"Parse errors in imported module '../src/handlers/telegram-handler-v2.js': Identifier 'handleCallbackQuery' has already been declared (535:23)","line":39,"column":23,"nodeType":"Literal","endLine":39,"endColumn":63},{"ruleId":"import/default","severity":2,"message":"Parse errors in imported module '../src/handlers/telegram-handler-v2.js': Identifier 'handleCallbackQuery' has already been declared (535:23)","line":39,"column":23,"nodeType":"Literal","endLine":39,"endColumn":63},{"ruleId":"import/no-named-as-default","severity":1,"message":"Parse errors in imported module '../src/handlers/telegram-handler-v2.js': Identifier 'handleCallbackQuery' has already been declared (535:23)","line":39,"column":23,"nodeType":"Literal","endLine":39,"endColumn":63},{"ruleId":"import/no-named-as-default-member","severity":1,"message":"Parse errors in imported module '../src/handlers/telegram-handler-v2.js': Identifier 'handleCallbackQuery' has already been declared (535:23)","line":39,"column":23,"nodeType":"Literal","endLine":39,"endColumn":63},{"ruleId":"no-dupe-else-if","severity":2,"message":"This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain.","line":89,"column":16,"nodeType":"LogicalExpression","messageId":"unexpected","endLine":89,"endColumn":107}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n/**\r\n * E2E Payment Callback Simulator\r\n * Tests the payment flow: tier selection -> payment method selection -> payment order\r\n */\r\n\r\n// Minimal in-memory Redis mock for local testing\r\nclass MockRedis {\r\n  constructor() {\r\n    this.store = new Map();\r\n    this.hashes = new Map();\r\n  }\r\n  async get(key) { return this.store.has(key) ? this.store.get(key) : null; }\r\n  async set(key, val) { this.store.set(key, String(val)); return 'OK'; }\r\n  async setex(key, ttl, val) { this.store.set(key, String(val)); return 'OK'; }\r\n  async del(key) { return this.store.delete(key) ? 1 : 0; }\r\n  async exists(key) { return this.store.has(key) ? 1 : 0; }\r\n  async hset(hash, field, val) { \r\n    if (!this.hashes.has(hash)) this.hashes.set(hash, new Map());\r\n    this.hashes.get(hash).set(field, String(val));\r\n    return 1;\r\n  }\r\n  async hget(hash, field) { return (this.hashes.get(hash) || new Map()).get(field) || null; }\r\n  async hgetall(hash) { \r\n    const map = this.hashes.get(hash) || new Map();\r\n    const obj = {};\r\n    for (const [k, v] of map) obj[k] = v;\r\n    return obj;\r\n  }\r\n  async hdel(hash, field) { return this.hashes.get(hash)?.delete(field) ? 1 : 0; }\r\n  async lpush(key, val) { if (!this.store.has(key)) this.store.set(key, []); this.store.get(key).push(val); return 1; }\r\n  async rpush(key, val) { if (!this.store.has(key)) this.store.set(key, []); this.store.get(key).push(val); return 1; }\r\n  async llen(key) { return (this.store.get(key) || []).length; }\r\n  async lrange(key, start, end) { return (this.store.get(key) || []).slice(start, end + 1); }\r\n  async expire(key, ttl) { return 1; }\r\n  async ttl(key) { return -1; }\r\n}\r\n\r\nimport v2Handler from '../src/handlers/telegram-handler-v2.js';\r\n\r\nconst redis = new MockRedis();\r\n\r\nasync function runPaymentTest() {\r\n  console.log('\\n=== E2E Payment Flow Test ===\\n');\r\n\r\n  const userId = 424242;\r\n  const chatId = 9999;\r\n  const services = {};\r\n\r\n  // Test 1: Tier selection (sub_vvip)\r\n  console.log('--- Test 1: Selecting VVIP tier (sub_vvip) ---');\r\n  const tierResponse = await v2Handler.handleCallbackQuery(\r\n    {\r\n      id: 'cb_001',\r\n      from: { id: userId },\r\n      message: { chat: { id: chatId }, message_id: 123 },\r\n      data: 'sub_vvip'\r\n    },\r\n    redis,\r\n    services\r\n  );\r\n  \r\n  if (tierResponse && tierResponse.reply_markup) {\r\n    const paymentButtons = tierResponse.reply_markup.inline_keyboard;\r\n    console.log(`Γ£ô Payment methods shown: ${paymentButtons.map(row => row[0].text).join(', ')}`);\r\n    console.log(`  First button data: ${paymentButtons[0][0].callback_data}`);\r\n  } else {\r\n    console.log('Γ¥î No payment methods in response');\r\n    console.log('Response:', tierResponse);\r\n  }\r\n\r\n  // Test 2: Payment method selection (pay_mpesa_vvip)\r\n  console.log('\\n--- Test 2: Selecting M-Pesa payment (pay_mpesa_vvip) ---');\r\n  try {\r\n    const paymentResponse = await v2Handler.handleCallbackQuery(\r\n      {\r\n        id: 'cb_002',\r\n        from: { id: userId },\r\n        message: { chat: { id: chatId }, message_id: 123 },\r\n        data: 'pay_mpesa_vvip'\r\n      },\r\n      redis,\r\n      services\r\n    );\r\n    \r\n    if (paymentResponse && paymentResponse.text) {\r\n      console.log(`Γ£ô Payment order created successfully`);\r\n      console.log(`  Response text preview: ${paymentResponse.text.substring(0, 80)}...`);\r\n    } else if (paymentResponse && paymentResponse.method === 'answerCallbackQuery' && paymentResponse.text) {\r\n      console.log(`ΓÜá∩╕Å  Alert: ${paymentResponse.text}`);\r\n    } else {\r\n      console.log('Γ¥î Unexpected response:', paymentResponse);\r\n    }\r\n  } catch (err) {\r\n    console.log(`Γ¥î Error: ${err.message}`);\r\n  }\r\n\r\n  // Test 3: Payment method selection with invalid method (should fail gracefully)\r\n  console.log('\\n--- Test 3: Selecting invalid payment (pay_invalid_vvip) ---');\r\n  try {\r\n    const invalidResponse = await v2Handler.handleCallbackQuery(\r\n      {\r\n        id: 'cb_003',\r\n        from: { id: userId },\r\n        message: { chat: { id: chatId }, message_id: 123 },\r\n        data: 'pay_invalid_vvip'\r\n      },\r\n      redis,\r\n      services\r\n    );\r\n    \r\n    if (invalidResponse && invalidResponse.method === 'answerCallbackQuery') {\r\n      console.log(`Γ£ô Gracefully handled invalid method: ${invalidResponse.text}`);\r\n    } else {\r\n      console.log('Γ¥î Should have returned answerCallbackQuery with error', invalidResponse);\r\n    }\r\n  } catch (err) {\r\n    console.log(`Γ¥î Unhandled error: ${err.message}`);\r\n  }\r\n\r\n  // Test 4: Different tier (sub_pro)\r\n  console.log('\\n--- Test 4: Selecting PRO tier (sub_pro) ---');\r\n  try {\r\n    const proResponse = await v2Handler.handleCallbackQuery(\r\n      {\r\n        id: 'cb_004',\r\n        from: { id: userId },\r\n        message: { chat: { id: chatId }, message_id: 123 },\r\n        data: 'sub_pro'\r\n      },\r\n      redis,\r\n      services\r\n    );\r\n    \r\n    if (proResponse && proResponse.reply_markup) {\r\n      const buttons = proResponse.reply_markup.inline_keyboard;\r\n      console.log(`Γ£ô PRO tier response has ${buttons.length} button groups`);\r\n      console.log(`  First payment option: ${buttons[0][0].text}`);\r\n    } else {\r\n      console.log('Γ¥î No buttons in PRO tier response');\r\n    }\r\n  } catch (err) {\r\n    console.log(`Γ¥î Error: ${err.message}`);\r\n  }\r\n\r\n  console.log('\\n=== Test Complete ===\\n');\r\n}\r\n\r\nrunPaymentTest().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\e2e-simulate.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'key' is defined but never used.","line":27,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":19},{"ruleId":"no-unused-vars","severity":2,"message":"'ttl' is defined but never used.","line":27,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":24},{"ruleId":"no-unused-vars","severity":2,"message":"'id' is defined but never used.","line":47,"column":98,"nodeType":"Identifier","messageId":"unusedVar","endLine":47,"endColumn":100}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n/*\r\n  Simple e2e simulation script for BETRIX handlers\r\n  - Uses MockRedis for local runs when requested\r\n  - Dynamically imports handlers so environment flags can be set before modules initialize\r\n*/\r\n// Force modules to use mock redis during this simulation to avoid noisy ioredis auth attempts\r\nprocess.env.USE_MOCK_REDIS = process.env.USE_MOCK_REDIS || '1';\r\n\r\n// Minimal in-memory Redis mock used for local e2e when real Redis is unavailable\r\nclass MockRedis {\r\n  constructor() {\r\n    this.store = new Map();\r\n    this.hashes = new Map();\r\n  }\r\n  async get(key) { return this.store.has(key) ? this.store.get(key) : null; }\r\n  async set(key, val) { this.store.set(key, String(val)); return 'OK'; }\r\n  async setex(key, ttl, val) { this.store.set(key, String(val)); return 'OK'; }\r\n  async del(key) { return this.store.delete(key) ? 1 : 0; }\r\n  async exists(key) { return this.store.has(key) ? 1 : 0; }\r\n  async incr(key) { const v = parseInt(await this.get(key) || '0', 10) + 1; await this.set(key, String(v)); return v; }\r\n  async hget(hash, field) { const h = this.hashes.get(hash) || {}; return (h[field] === undefined) ? null : h[field]; }\r\n  async hset(hash, field, val) { const h = this.hashes.get(hash) || {}; h[field] = String(val); this.hashes.set(hash, h); return 1; }\r\n  async lpush(key, val) { const arr = this.store.get(key) ? JSON.parse(this.store.get(key)) : []; arr.unshift(val); this.store.set(key, JSON.stringify(arr)); return arr.length; }\r\n  async rpush(key, val) { const arr = this.store.get(key) ? JSON.parse(this.store.get(key)) : []; arr.push(val); this.store.set(key, JSON.stringify(arr)); return arr.length; }\r\n  async lrange(key, start, stop) { const arr = this.store.get(key) ? JSON.parse(this.store.get(key)) : []; return arr.slice(start, stop + 1); }\r\n  async expire(key, ttl) { /* noop */ return 1; }\r\n  quit() { /* noop */ }\r\n}\r\n\r\nasync function run() {\r\n  try {\r\n    // We intentionally do NOT import Redis from ioredis here since USE_MOCK_REDIS=1 is set above\r\n    // All app modules loaded during the dynamic import will use the factory and respect USE_MOCK_REDIS\r\n    \r\n    // Dynamically import handlers after setting USE_MOCK_REDIS\r\n    const { handleMessage, handleCallbackQuery } = await import('../src/handlers/telegram-handler-v2.js');\r\n    const redisClient = new MockRedis(); // use mock directly in e2e\r\n    const mockUpdate = { message: { chat: { id: 9999 }, from: { id: 424242 }, text: '/live' } };\r\n    console.log('--- Running /live simulation ---');\r\n    const res = await handleMessage(mockUpdate, redisClient, { apiFootball: { getLive: async () => ({ response: [ { fixture: { id: 11111, status: { short: 'LIVE', elapsed: 12 } }, teams: { home: { name: 'Home FC' }, away: { name: 'Away United' } }, goals: { home: 1, away: 0 } } ] }) } });\r\n    console.log('Message result:', res);\r\n\r\n    // Simulate pressing quick bet callback for fixture 11111\r\n    console.log('--- Simulating bet callback ---');\r\n    const cb = { id: 'cb1', from: { id: 424242 }, message: { chat: { id: 9999 } }, data: 'bet_fixture_11111' };\r\n    const cbRes = await handleCallbackQuery(cb, redisClient, { apiFootball: { getFixture: async (id) => ({ response: [ { teams: { home: { name: 'Home FC' }, away: { name: 'Away United' } } } ] }) } });\r\n    console.log('Callback result:', cbRes);\r\n    \r\n    // Simulate a payment flow if payment-router available\r\n    try {\r\n      const payment = await import('../src/handlers/payment-router.js');\r\n      console.log('--- Simulating payment flow ---');\r\n      const order = await payment.createPaymentOrder(redisClient, 424242, 'PLUS', 'SAFARICOM_TILL', 'KE', { phone: '+254700000000' });\r\n      console.log('Created order:', order.orderId, order.totalAmount);\r\n      const instr = await payment.getPaymentInstructions(redisClient, order.orderId, order.paymentMethod);\r\n      console.log('Payment instructions:', instr && instr.description ? instr.description : instr);\r\n      const result = await payment.simulatePaymentComplete(redisClient, order.orderId);\r\n      console.log('Payment result:', result);\r\n    } catch (e) {\r\n      console.warn('Payment simulation skipped:', e && e.message);\r\n    }\r\n  } catch (err) {\r\n    console.error('e2e-simulate error', err);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nrun();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\e2e_dev_runner.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'err' is defined but never used.","line":18,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":25},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":38,"column":47,"nodeType":"BlockStatement","messageId":"unexpected","endLine":38,"endColumn":49,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[1440,1440],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":43,"column":47,"nodeType":"BlockStatement","messageId":"unexpected","endLine":43,"endColumn":49,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[1610,1610],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":48,"column":46,"nodeType":"BlockStatement","messageId":"unexpected","endLine":48,"endColumn":48,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[1781,1781],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n// Starts the dev server, waits for port 5000 to accept TCP, then runs the STK simulator.\r\nimport { spawn } from 'child_process';\r\nimport net from 'net';\r\nimport path from 'path';\r\n\r\nconst serverCmd = process.execPath; // node\r\nconst serverArgs = [path.join('scripts', 'run_server_dev.js')];\r\n\r\nfunction waitForPort(host, port, timeoutMs = 10000) {\r\n  const start = Date.now();\r\n  return new Promise((resolve, reject) => {\r\n    (function attempt() {\r\n      const s = net.createConnection({ host, port }, () => {\r\n        s.end();\r\n        resolve(true);\r\n      });\r\n      s.on('error', (err) => {\r\n        if (Date.now() - start > timeoutMs) return reject(new Error('timeout'));\r\n        setTimeout(attempt, 200);\r\n      });\r\n    })();\r\n  });\r\n}\r\n\r\nasync function run() {\r\n  console.log('Starting dev server...');\r\n  const child = spawn(serverCmd, serverArgs, { stdio: 'inherit', shell: false, env: process.env });\r\n\r\n  try {\r\n    await waitForPort('127.0.0.1', 5000, 15000);\r\n    console.log('Port 5000 is accepting connections ΓÇö running simulator');\r\n    // Run simulator in same process\r\n    const sim = spawn(serverCmd, [path.join('scripts', 'simulate_stk_e2e.js')], { stdio: 'inherit', shell: false, env: process.env });\r\n    sim.on('exit', (code) => {\r\n      console.log('Simulator exited with code', code);\r\n      // Kill server child and exit with simulator code\r\n      try { child.kill('SIGINT'); } catch (e) {}\r\n      process.exit(code || 0);\r\n    });\r\n    sim.on('error', (err) => {\r\n      console.error('Simulator failed', err);\r\n      try { child.kill('SIGINT'); } catch (e) {}\r\n      process.exit(1);\r\n    });\r\n  } catch (e) {\r\n    console.error('Port wait failed', e && e.message ? e.message : e);\r\n    try { child.kill('SIGINT'); } catch (er) {}\r\n    process.exit(2);\r\n  }\r\n}\r\n\r\nrun().catch(e => { console.error(e); process.exit(1); });\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\enqueue-test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\format-live-sample.js","messages":[{"ruleId":"import/no-named-as-default","severity":1,"message":"Using exported name 'SportsAggregator' as identifier for default import.","line":5,"column":8,"nodeType":"ImportDefaultSpecifier","endLine":5,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\nimport dotenv from 'dotenv';\r\ndotenv.config();\r\nimport IORedis from 'ioredis';\r\nimport SportsAggregator from '../src/services/sports-aggregator.js';\r\nimport * as MH from '../src/handlers/menu-handler.js';\r\n\r\nasync function main() {\r\n  const redisUrl = process.env.REDIS_URL;\r\n  let redis = null;\r\n  if (redisUrl) redis = new IORedis(redisUrl);\r\n  const agg = new SportsAggregator(redis);\r\n  try {\r\n    const matches = await agg.getLiveMatches('39');\r\n    const msg = MH.formatLiveGames(matches, 'Football');\r\n    console.log('=== Formatted Live Menu ===');\r\n    console.log(msg.substring(0, 4000));\r\n  } catch (e) {\r\n    console.error('Failed to build live menu:', e?.message || e);\r\n  } finally {\r\n    try { if (redis) await redis.quit(); } catch (_) { if (redis) redis.disconnect(); }\r\n  }\r\n}\r\n\r\nmain();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\get_latest_payment_txref.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\health-server.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":37,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":37,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":37,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":37,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":41,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":41,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":42,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":42,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":47,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":47,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":51,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":51,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":52,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":52,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":57,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":57,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":70,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":70,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":71,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":71,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":76,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":76,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":79,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":79,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":81,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":81,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":84,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":84,"endColumn":10},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":95,"column":111,"nodeType":"BlockStatement","messageId":"unexpected","endLine":95,"endColumn":113,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[3826,3826],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":96,"column":127,"nodeType":"BlockStatement","messageId":"unexpected","endLine":96,"endColumn":129,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[3955,3955],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'payload' is defined but never used.","line":124,"column":59,"nodeType":"Identifier","messageId":"unusedVar","endLine":124,"endColumn":66},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":136,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":136,"endColumn":10},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":148,"column":40,"nodeType":"BlockStatement","messageId":"unexpected","endLine":148,"endColumn":42,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[8005,8005],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const http = require(\"http\");\nconst url = require(\"url\");\nconst { createQueue } = require(\"../src/server/queue\");\nconst PORT = process.env.PORT || 10000;\nlet metricsQueue;\n\nfunction getMetricsQueue() {\n  if (!metricsQueue) metricsQueue = createQueue(\"betrix-jobs\");\n  return metricsQueue;\n}\n\nconst server = http.createServer(async (req, res) => {\n  const { pathname } = url.parse(req.url);\n  if (pathname === \"/healthz\") return res.end(JSON.stringify({ ok: true, ts: Date.now() }));\n  if (pathname === \"/metrics\") {\n    try {\n      const counts = await getMetricsQueue().getJobCounts();\n      res.setHeader(\"Content-Type\",\"application/json\");\n      return res.end(JSON.stringify({ ok: true, counts }));\n    } catch (e) {\n      res.statusCode = 500; return res.end(JSON.stringify({ ok: false, error: e.message }));\n    }\n  }\n  res.end(\"ok\");\n});\nserver.listen(PORT, () => console.log(\"[health] server listening on port\", PORT));\n\r\n/* COPILOT-READY-ENDPOINT - START\n   Idempotent readiness and liveness endpoints.\n   - /health: liveness (very cheap)\n   - /ready: readiness (returns 200 only when globalThis.__isReady is true)\n   This block is safe to insert multiple times; it checks for existing app and markers.\n*/\ntry {\n  if (typeof app !== \"undefined\" && typeof globalThis.__copilotReadyInserted === \"undefined\") {\n    globalThis.__copilotReadyInserted = true;\n    if (!app._router || !app._router.stack) {\n      // If app exists but router not ready, still attach endpoints\n    }\n    // Liveness\n    if (!app._copilotHasHealth) {\n      app.get('/health', (req, res) => {\n        try {\n          res.status(200).json({ status: 'healthy', uptime: process.uptime(), redis: !!globalThis.redisClient, version: process.env.npm_package_version || process.env.VERSION || 'unknown' });\n        } catch (e) { res.status(200).send('ok'); }\n      });\n      app._copilotHasHealth = true;\n    }\n\n    // Readiness\n    if (!app._copilotHasReady) {\n      app.get('/ready', (req, res) => {\n        try {\n          res.status(globalThis.__isReady ? 200 : 503).send(globalThis.__isReady ? 'ready' : 'not ready');\n        } catch (e) { res.status(503).send('not ready'); }\n      });\n      app._copilotHasReady = true;\n    }\n  }\n} catch (e) { console.error('COPILOT-READY-ENDPOINT ERROR', e); }\n/* COPILOT-READY-ENDPOINT - END */\r\n\r\n/* COPILOT-OPS-LIFECYCLE - START\n   Idempotent: adds /health and /ready, queue wrapper (Bull/BullMQ/ioredis fallback), and graceful shutdown.\n*/\ntry {\n  if (typeof app !== \"undefined\" && typeof globalThis.__copilotOpsInserted === \"undefined\") {\n    globalThis.__copilotOpsInserted = true;\n    // Liveness\n    if (!app._copilotHasHealth) {\n      app.get('/health', (req, res) => {\n        try {\n          res.status(200).json({ status: 'healthy', uptime: process.uptime(), redis: !!globalThis.redisClient, version: process.env.npm_package_version || process.env.VERSION || 'unknown' });\n        } catch (e) { res.status(200).send('ok'); }\n      });\n      app._copilotHasHealth = true;\n    }\n    // Readiness\n    if (!app._copilotHasReady) {\n      globalThis.__isReady = (typeof globalThis.__isReady === 'undefined') ? true : globalThis.__isReady;\n      app.get('/ready', (req, res) => {\n        try { res.status(globalThis.__isReady ? 200 : 503).send(globalThis.__isReady ? 'ready' : 'not ready'); } catch (e) { res.status(503).send('not ready'); }\n      });\n      app._copilotHasReady = true;\n    }\n\n    // Queue wrapper\n    (function(){\n      if (globalThis.queue && globalThis.queue.__copilotWrapped) return;\n      const wrapper = { __copilotWrapped: true };\n      function safeLog(o){ try{ console.log(JSON.stringify(o)); }catch(e){ console.log(o); } }\n\n      try {\n        let QueueClient = null;\n        try { QueueClient = require('bullmq').Queue; safeLog({event:'queue.impl','impl':'bullmq'}); } catch(e){}\n        if (!QueueClient) { try { QueueClient = require('bull').Queue; safeLog({event:'queue.impl','impl':'bull'}); } catch(e){} }\n\n        if (QueueClient) {\n          if (globalThis.myQueue) {\n            wrapper.enqueue = async (name,payload)=>{ try{ await globalThis.myQueue.add(name,payload); safeLog({event:'webhook.enqueued',name}); }catch(e){ safeLog({event:'enqueue.error',error:e.message}); } };\n            wrapper.drain = async ()=>{ try{ if(globalThis.myQueue.close) await globalThis.myQueue.close(); safeLog({event:'queue.closed'}); }catch(e){ safeLog({event:'drain.error',error:e.message}); } };\n          } else {\n            try {\n              const q = new QueueClient('telegram-updates');\n              globalThis.myQueue = q;\n              wrapper.enqueue = async (name,payload)=>{ try{ await q.add(name,payload); safeLog({event:'webhook.enqueued',name}); }catch(e){ safeLog({event:'enqueue.error',error:e.message}); } };\n              wrapper.drain = async ()=>{ try{ if(q.close) await q.close(); safeLog({event:'queue.closed'}); }catch(e){ safeLog({event:'drain.error',error:e.message}); } };\n            } catch(e){ safeLog({event:'queue.create.failed',error:e.message}); }\n          }\n        }\n      } catch(e){ safeLog({event:'queue.require.failed',error:e.message}); }\n\n      if (!wrapper.enqueue || !wrapper.drain) {\n        try {\n          const IORedis = require('ioredis');\n          const redisUrl = process.env.REDIS_URL || process.env.REDIS || 'redis://127.0.0.1:6379';\n          const redisClient = new IORedis(redisUrl);\n          globalThis.redisClient = redisClient;\n          wrapper.enqueue = async (name,payload)=>{ try{ await redisClient.rpush('queue:telegram:updates', JSON.stringify(payload)); safeLog({event:'webhook.enqueued.redis'}); }catch(e){ safeLog({event:'enqueue.redis.error',error:e.message}); } };\n          wrapper.drain = async ()=>{ try{ const timeout = parseInt(process.env.SHUTDOWN_TIMEOUT_MS||'30000',10); const start=Date.now(); while((Date.now()-start)<timeout){ const len = await redisClient.llen('queue:telegram:updates'); if(len===0) break; await new Promise(r=>setTimeout(r,200)); } safeLog({event:'queue.drained.redis'}); }catch(e){ safeLog({event:'drain.redis.error',error:e.message}); } };\n        } catch(e){ safeLog({event:'ioredis.not.available',error:e.message}); }\n      }\n\n      if (!wrapper.enqueue) wrapper.enqueue = async (name,payload)=>{ safeLog({event:'enqueue.noop',name}); };\n      if (!wrapper.drain) wrapper.drain = async ()=>{ safeLog({event:'drain.noop'}); };\n\n      globalThis.queue = wrapper;\n      safeLog({event:'queue.wrapper.ready'});\n    })();\n\n    // Graceful shutdown\n    (function(){\n      const shutdownTimeoutMs = parseInt(process.env.SHUTDOWN_TIMEOUT_MS || '30000',10);\n      let shuttingDown = false;\n      let inflight = 0;\n      app.use((req,res,next)=>{\n        if (shuttingDown) { res.setHeader('Connection','close'); return res.status(503).send('shutting down'); }\n        inflight++; res.on('finish',()=>{ inflight = Math.max(0,inflight-1); }); next();\n      });\n      async function doShutdown(signal){\n        if (shuttingDown) return; shuttingDown = true; globalThis.__isReady = false;\n        console.info(JSON.stringify({event:'shutdown.initiated',signal,timestamp:new Date().toISOString(),inflight}));\n        try{ if(typeof server !== 'undefined' && server && server.close) server.close(()=>{ console.info(JSON.stringify({event:'http.closed',timestamp:new Date().toISOString()})); }); }catch(e){ console.error('error closing server',e); }\n        const start = Date.now();\n        while(inflight>0 && (Date.now()-start) < shutdownTimeoutMs){ await new Promise(r=>setTimeout(r,200)); }\n        try{ if(globalThis.queue && typeof globalThis.queue.drain === 'function'){ await globalThis.queue.drain(); console.info(JSON.stringify({event:'queue.drained',timestamp:new Date().toISOString()})); } else { console.info('No queue.drain found; best-effort drain.'); } }catch(e){ console.error('queue drain error',e); }\n        console.info(JSON.stringify({event:'shutdown.complete',timestamp:new Date().toISOString(),inflight}));\n        try{ process.exit(0); }catch(e){}\n      }\n      process.on('SIGTERM',()=>doShutdown('SIGTERM')); process.on('SIGINT',()=>doShutdown('SIGINT'));\n    })();\n  }\n} catch(e){ console.error('COPILOT-OPS-LIFECYCLE ERROR', e); }\n/* COPILOT-OPS-LIFECYCLE - END */\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\hf-discover.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\inspect-redis-prefetch.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\inspect-sportmonks-cert.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\inspect_webhooks.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\lipana_try_correct_payload.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\manage-telegram-webhook.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\mapping-miss-monitor.js","messages":[{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":53,"column":44,"nodeType":"BlockStatement","messageId":"unexpected","endLine":53,"endColumn":46,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[1701,1701],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\nimport Redis from 'ioredis';\r\nimport fetch from 'node-fetch';\r\n\r\nasync function sendTelegram(token, chatId, text) {\r\n  try {\r\n    const res = await fetch(`https://api.telegram.org/bot${token}/sendMessage`, {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({ chat_id: chatId, text }),\r\n    });\r\n    return res.ok;\r\n  } catch (e) {\r\n    console.error('Telegram send error', e.message || e);\r\n    return false;\r\n  }\r\n}\r\n\r\n(async () => {\r\n  const redisUrl = process.env.REDIS_URL || 'redis://127.0.0.1:6379';\r\n  const redis = new Redis(redisUrl);\r\n  try {\r\n    const keys = await redis.keys('monitor:payment:mapping_misses:*');\r\n    if (!keys || keys.length === 0) {\r\n      console.log('No mapping-miss keys found.');\r\n      process.exit(0);\r\n    }\r\n\r\n    const rows = [];\r\n    for (const k of keys) {\r\n      const val = await redis.get(k);\r\n      rows.push({ key: k, count: Number(val || 0) });\r\n    }\r\n\r\n    rows.sort((a, b) => b.count - a.count);\r\n    const summary = rows.map(r => `${r.key.split(':').pop()}: ${r.count}`).join('\\n');\r\n    const message = `Mapping-miss summary:\\n${summary}`;\r\n\r\n    console.log(message);\r\n\r\n    const tg = process.env.TELEGRAM_TOKEN;\r\n    const admin = process.env.ADMIN_TELEGRAM_ID;\r\n    if (tg && admin) {\r\n      const ok = await sendTelegram(tg, admin, message);\r\n      console.log('Telegram send:', ok ? 'ok' : 'failed');\r\n    } else {\r\n      console.log('TELEGRAM_TOKEN or ADMIN_TELEGRAM_ID not set; skipping Telegram notification.');\r\n    }\r\n  } catch (e) {\r\n    console.error('Monitor failed:', e);\r\n    process.exit(2);\r\n  } finally {\r\n    try { redis.disconnect(); } catch (ex) {}\r\n  }\r\n})();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\mark_payment_success_supabase.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\mark_pending_success.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\merge-populate-prefetch.js","messages":[{"ruleId":"import/no-named-as-default","severity":1,"message":"Using exported name 'SportsAggregator' as identifier for default import.","line":5,"column":8,"nodeType":"ImportDefaultSpecifier","endLine":5,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\nimport dotenv from 'dotenv';\r\ndotenv.config();\r\nimport IORedis from 'ioredis';\r\nimport SportsAggregator from '../src/services/sports-aggregator.js';\r\n\r\nasync function main() {\r\n  const redisUrl = process.env.REDIS_URL;\r\n  if (!redisUrl) {\r\n    console.error('REDIS_URL not set in environment');\r\n    process.exit(2);\r\n  }\r\n\r\n  const redis = new IORedis(redisUrl);\r\n  const agg = new SportsAggregator(redis);\r\n\r\n  try {\r\n    console.log('Fetching live soccer matches from aggregator...');\r\n    const matches = await agg.getLiveMatches('39');\r\n    if (!Array.isArray(matches) || matches.length === 0) {\r\n      console.log('No matches returned by aggregator. Aborting prefetch merge.');\r\n      process.exit(0);\r\n    }\r\n\r\n    const samples = matches.slice(0, 20);\r\n    const key = 'betrix:prefetch:live:by-sport';\r\n    const raw = await redis.get(key).catch(() => null);\r\n    let payload = { timestamp: new Date().toISOString(), sports: {}, totalMatches: samples.length };\r\n    if (raw) {\r\n      try { payload = JSON.parse(raw); } catch(e) { payload = { timestamp: new Date().toISOString(), sports: {}, totalMatches: samples.length }; }\r\n    }\r\n\r\n    payload.timestamp = new Date().toISOString();\r\n    payload.sports = payload.sports || {};\r\n    payload.sports.soccer = { count: matches.length, samples };\r\n    payload.totalMatches = Object.values(payload.sports).reduce((s, v) => s + (v.count || 0), 0);\r\n\r\n    await redis.set(key, JSON.stringify(payload));\r\n    await redis.set('live:39', JSON.stringify(samples));\r\n    console.log('Merged and wrote prefetch key with soccer samples.');\r\n  } catch (e) {\r\n    console.error('Failed to merge prefetch:', e?.message || e);\r\n    process.exit(1);\r\n  } finally {\r\n    try { await redis.quit(); } catch (_) { redis.disconnect(); }\r\n  }\r\n}\r\n\r\nmain();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\monitor-payment-health.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\monitor-redis-health.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'info' is assigned a value but never used.","line":131,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":131,"endColumn":15},{"ruleId":"no-unused-vars","severity":2,"message":"'err' is defined but never used.","line":291,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":291,"endColumn":23}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n/**\r\n * REDIS HEALTH MONITOR & SEAMLESS CONNECTION CHECKER\r\n * Continuously monitors Redis health and reports status\r\n * Run: node scripts/monitor-redis-health.js\r\n */\r\n\r\nimport dotenv from 'dotenv';\r\nimport Redis from 'ioredis';\r\n\r\ndotenv.config();\r\n\r\nconst REDIS_URL = process.env.REDIS_URL;\r\nconst CHECK_INTERVAL = process.env.REDIS_HEALTH_CHECK_INTERVAL || 30000; // 30 seconds\r\nconst ALERT_THRESHOLD = process.env.REDIS_ALERT_THRESHOLD || 5; // Alert after 5 consecutive failures\r\n\r\n// ============================================================================\r\n// INITIALIZATION\r\n// ============================================================================\r\n\r\nif (!REDIS_URL) {\r\n  console.error('Γ¥î CRITICAL: REDIS_URL environment variable not set');\r\n  process.exit(1);\r\n}\r\n\r\nconst redis = new Redis(REDIS_URL, {\r\n  connectTimeout: 5000,\r\n  maxRetriesPerRequest: 1,\r\n  enableReadyCheck: true,\r\n  enableOfflineQueue: false,\r\n  retryStrategy: (times) => {\r\n    if (times > 3) return null;\r\n    return Math.min(times * 100, 1000);\r\n  }\r\n});\r\n\r\nlet consecutiveFailures = 0;\r\nlet lastErrorTime = null;\r\nlet isHealthy = false;\r\n\r\n// ============================================================================\r\n// METRICS\r\n// ============================================================================\r\n\r\nclass HealthMetrics {\r\n  constructor() {\r\n    this.totalChecks = 0;\r\n    this.successfulChecks = 0;\r\n    this.failedChecks = 0;\r\n    this.avgResponseTime = 0;\r\n    this.maxResponseTime = 0;\r\n    this.minResponseTime = Infinity;\r\n    this.startTime = Date.now();\r\n    this.errors = [];\r\n  }\r\n\r\n  recordSuccess(responseTime) {\r\n    this.successfulChecks++;\r\n    this.totalChecks++;\r\n    this.avgResponseTime = (this.avgResponseTime + responseTime) / 2;\r\n    this.maxResponseTime = Math.max(this.maxResponseTime, responseTime);\r\n    this.minResponseTime = Math.min(this.minResponseTime, responseTime);\r\n  }\r\n\r\n  recordFailure(error) {\r\n    this.failedChecks++;\r\n    this.totalChecks++;\r\n    this.errors.push({\r\n      timestamp: new Date().toISOString(),\r\n      error: error.message,\r\n      code: error.code\r\n    });\r\n    // Keep only last 10 errors\r\n    if (this.errors.length > 10) {\r\n      this.errors.shift();\r\n    }\r\n  }\r\n\r\n  getSuccessRate() {\r\n    return this.totalChecks === 0 ? 0 : ((this.successfulChecks / this.totalChecks) * 100).toFixed(1);\r\n  }\r\n\r\n  getUptimeSeconds() {\r\n    return Math.floor((Date.now() - this.startTime) / 1000);\r\n  }\r\n\r\n  getReport() {\r\n    return {\r\n      totalChecks: this.totalChecks,\r\n      successfulChecks: this.successfulChecks,\r\n      failedChecks: this.failedChecks,\r\n      successRate: `${this.getSuccessRate()}%`,\r\n      responseTime: {\r\n        avg: `${this.avgResponseTime.toFixed(2)}ms`,\r\n        min: this.minResponseTime === Infinity ? 'N/A' : `${this.minResponseTime.toFixed(2)}ms`,\r\n        max: `${this.maxResponseTime.toFixed(2)}ms`\r\n      },\r\n      uptime: `${this.getUptimeSeconds()}s`,\r\n      recentErrors: this.errors.slice(-3)\r\n    };\r\n  }\r\n}\r\n\r\nconst metrics = new HealthMetrics();\r\n\r\n// ============================================================================\r\n// HEALTH CHECK FUNCTIONS\r\n// ============================================================================\r\n\r\nasync function performHealthCheck() {\r\n  const checkStartTime = Date.now();\r\n\r\n  try {\r\n    // Test 1: PING\r\n    const pingResult = await redis.ping();\r\n    if (pingResult !== 'PONG') {\r\n      throw new Error(`PING returned ${pingResult} instead of PONG`);\r\n    }\r\n\r\n    // Test 2: GET/SET operation\r\n    const testKey = `__health_check_${Date.now()}__`;\r\n    const testValue = 'ok';\r\n    await redis.setex(testKey, 60, testValue);\r\n    const retrievedValue = await redis.get(testKey);\r\n    \r\n    if (retrievedValue !== testValue) {\r\n      throw new Error(`GET/SET test failed: expected '${testValue}', got '${retrievedValue}'`);\r\n    }\r\n\r\n    // Test 3: Database info\r\n    const info = await redis.info('stats');\r\n    \r\n    // Test 4: Command latency\r\n    const latencyStart = Date.now();\r\n    await redis.command();\r\n    const latency = Date.now() - latencyStart;\r\n\r\n    const responseTime = Date.now() - checkStartTime;\r\n    metrics.recordSuccess(responseTime);\r\n    isHealthy = true;\r\n    consecutiveFailures = 0;\r\n    lastErrorTime = null;\r\n\r\n    return {\r\n      status: 'healthy',\r\n      timestamp: new Date().toISOString(),\r\n      responseTime: `${responseTime}ms`,\r\n      latency: `${latency}ms`,\r\n      tests: {\r\n        ping: 'PASS',\r\n        getset: 'PASS',\r\n        info: 'PASS',\r\n        command: 'PASS'\r\n      }\r\n    };\r\n\r\n  } catch (error) {\r\n    const responseTime = Date.now() - checkStartTime;\r\n    metrics.recordFailure(error);\r\n    consecutiveFailures++;\r\n    lastErrorTime = new Date().toISOString();\r\n    isHealthy = false;\r\n\r\n    return {\r\n      status: 'unhealthy',\r\n      timestamp: new Date().toISOString(),\r\n      responseTime: `${responseTime}ms`,\r\n      error: error.message,\r\n      code: error.code,\r\n      consecutiveFailures: consecutiveFailures,\r\n      willAlert: consecutiveFailures >= ALERT_THRESHOLD\r\n    };\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// DISPLAY & LOGGING\r\n// ============================================================================\r\n\r\nfunction formatOutput(result) {\r\n  const timestamp = new Date().toLocaleString();\r\n  const statusIcon = result.status === 'healthy' ? 'Γ£à' : 'Γ¥î';\r\n  \r\n  console.clear();\r\n  console.log('\\n');\r\n  console.log('ΓòöΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòù');\r\n  console.log('Γòæ         BETRIX REDIS HEALTH MONITOR - SEAMLESS STATUS          Γòæ');\r\n  console.log('ΓòÜΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓò¥\\n');\r\n  \r\n  console.log(`${statusIcon} Status: ${result.status.toUpperCase()}`);\r\n  console.log(`≡ƒôà Check Time: ${timestamp}`);\r\n  console.log(`ΓÅ▒∩╕Å  Response Time: ${result.responseTime}`);\r\n  \r\n  if (result.status === 'healthy') {\r\n    console.log(`≡ƒöù Latency: ${result.latency}`);\r\n    console.log(`\\nΓ£¿ All Tests Passed:`);\r\n    Object.entries(result.tests).forEach(([test, status]) => {\r\n      console.log(`   Γ£ô ${test.toUpperCase()}: ${status}`);\r\n    });\r\n  } else {\r\n    console.log(`ΓÜá∩╕Å  Error: ${result.error}`);\r\n    console.log(`≡ƒôè Consecutive Failures: ${result.consecutiveFailures}`);\r\n    if (result.willAlert) {\r\n      console.log(`\\n≡ƒÜ¿ ALERT: Redis connection issues detected!`);\r\n      console.log(`   Action: Check network, Redis status, and credentials`);\r\n    }\r\n  }\r\n\r\n  console.log('\\nΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöü\\n');\r\n  \r\n  const report = metrics.getReport();\r\n  console.log('≡ƒôè METRICS (Session Total):\\n');\r\n  console.log(`   Total Checks: ${report.totalChecks}`);\r\n  console.log(`   Success Rate: ${report.successRate}`);\r\n  console.log(`   Response Time:`);\r\n  console.log(`     ΓÇó Average: ${report.responseTime.avg}`);\r\n  console.log(`     ΓÇó Min: ${report.responseTime.min}`);\r\n  console.log(`     ΓÇó Max: ${report.responseTime.max}`);\r\n  console.log(`   Uptime: ${report.uptime}`);\r\n  \r\n  if (report.recentErrors.length > 0) {\r\n    console.log(`\\n   Last ${report.recentErrors.length} Error(s):`);\r\n    report.recentErrors.forEach((err, idx) => {\r\n      console.log(`     ${idx + 1}. [${err.code}] ${err.error} (${err.timestamp})`);\r\n    });\r\n  }\r\n\r\n  console.log('\\nΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöüΓöü\\n');\r\n  \r\n  if (result.status === 'healthy') {\r\n    console.log('≡ƒÄë Redis connection is SEAMLESS and HEALTHY');\r\n    console.log('≡ƒÜÇ All BETRIX bot features are operational\\n');\r\n  } else {\r\n    console.log('ΓÜá∩╕Å  Redis connection has ISSUES');\r\n    if (consecutiveFailures >= ALERT_THRESHOLD) {\r\n      console.log('≡ƒÜ¿ CRITICAL: Multiple failures detected');\r\n    }\r\n    console.log('≡ƒôï Recommendations:');\r\n    console.log('   1. Verify REDIS_URL is correctly set');\r\n    console.log('   2. Check network connectivity to Redis host');\r\n    console.log('   3. Verify Redis credentials are correct');\r\n    console.log('   4. Check firewall/security group rules');\r\n    console.log('   5. Restart worker: npm run worker\\n');\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// CONTINUOUS MONITORING\r\n// ============================================================================\r\n\r\nasync function startMonitoring() {\r\n  console.log(`≡ƒöä Starting Redis health monitoring every ${CHECK_INTERVAL / 1000}s...\\n`);\r\n\r\n  // Initial check\r\n  const result = await performHealthCheck();\r\n  formatOutput(result);\r\n\r\n  // Continuous monitoring\r\n  setInterval(async () => {\r\n    const result = await performHealthCheck();\r\n    \r\n    // Only display full output on status change or failure\r\n    if (result.status === 'unhealthy' || !isHealthy) {\r\n      formatOutput(result);\r\n    } else {\r\n      // Brief status for healthy checks\r\n      process.stdout.write(`\\rΓ£à Healthy (${metrics.totalChecks} checks, ${metrics.getSuccessRate()}% success rate)`);\r\n    }\r\n\r\n    // Send alert if threshold exceeded\r\n    if (consecutiveFailures >= ALERT_THRESHOLD) {\r\n      console.error('\\n≡ƒÜ¿ ALERT: Redis connection threshold exceeded!');\r\n      console.error(`Last error: ${lastErrorTime}`);\r\n      console.error(`Consecutive failures: ${consecutiveFailures}\\n`);\r\n    }\r\n  }, CHECK_INTERVAL);\r\n\r\n  // Graceful shutdown\r\n  process.on('SIGINT', () => {\r\n    console.log('\\n\\n≡ƒôï Final Report:');\r\n    console.log(JSON.stringify(metrics.getReport(), null, 2));\r\n    redis.quit();\r\n    process.exit(0);\r\n  });\r\n}\r\n\r\n// ============================================================================\r\n// EVENT HANDLERS\r\n// ============================================================================\r\n\r\nredis.on('error', (err) => {\r\n  // Errors are handled in performHealthCheck\r\n});\r\n\r\nredis.on('connect', () => {\r\n  console.log('[redis-health] Γ£à Connected to Redis');\r\n});\r\n\r\nredis.on('end', () => {\r\n  console.log('[redis-health] ΓÜá∩╕Å  Redis connection ended');\r\n});\r\n\r\n// ============================================================================\r\n// MAIN\r\n// ============================================================================\r\n\r\nstartMonitoring().catch((error) => {\r\n  console.error('Γ¥î Failed to start health monitor:', error.message);\r\n  process.exit(1);\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\poll_lipana_transaction.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\poll_lipana_tx.js","messages":[{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":15,"column":3,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":19,"endColumn":27}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\nimport fetch from 'node-fetch';\r\n\r\nconst API_BASE = process.env.LIPANA_API_BASE || 'https://api.lipana.dev';\r\nconst KEY = process.argv[2] || process.env.LIPANA_API_KEY;\r\nconst REF = process.argv[3] || process.env.REFERENCE;\r\nconst INTERVAL = Number(process.argv[4] || process.env.POLL_INTERVAL || 5000);\r\nconst TIMEOUT = Number(process.argv[5] || process.env.POLL_TIMEOUT || 3 * 60 * 1000);\r\n\r\nif (!KEY) { console.error('LIPANA_API_KEY required'); process.exit(2); }\r\nif (!REF) { console.error('REFERENCE required'); process.exit(2); }\r\n\r\nasync function query() {\r\n  const url = `${API_BASE}/v1/transactions?reference=${encodeURIComponent(REF)}`;\r\n  try {\r\n    const res = await fetch(url, { headers: { 'x-api-key': KEY }, timeout: 10000 });\r\n    const j = await res.json();\r\n    return j;\r\n  } catch (e) { throw e; }\r\n}\r\n\r\nasync function poll() {\r\n  const start = Date.now();\r\n  while (Date.now() - start < TIMEOUT) {\r\n    try {\r\n      const j = await query();\r\n      console.log(new Date().toISOString(), JSON.stringify(j));\r\n      const status = j?.data && j.data[0] && j.data[0].status;\r\n      if (status && ['success','failed','timeout','cancelled'].includes(status.toLowerCase())) {\r\n        console.log('Terminal status:', status);\r\n        return j;\r\n      }\r\n    } catch (e) {\r\n      console.error('Query error', e.message || e);\r\n    }\r\n    await new Promise(r => setTimeout(r, INTERVAL));\r\n  }\r\n  console.error('Polling timed out');\r\n  process.exit(1);\r\n}\r\n\r\npoll().then(j => { console.log('Done', j); process.exit(0); }).catch(e => { console.error(e); process.exit(1); });\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\populate-prefetch.js","messages":[{"ruleId":"import/no-named-as-default","severity":1,"message":"Using exported name 'SportsAggregator' as identifier for default import.","line":5,"column":8,"nodeType":"ImportDefaultSpecifier","endLine":5,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\nimport dotenv from 'dotenv';\r\ndotenv.config();\r\nimport IORedis from 'ioredis';\r\nimport SportsAggregator from '../src/services/sports-aggregator.js';\r\n\r\nasync function main() {\r\n  const redisUrl = process.env.REDIS_URL;\r\n  if (!redisUrl) {\r\n    console.error('REDIS_URL not set in environment');\r\n    process.exit(2);\r\n  }\r\n\r\n  const redis = new IORedis(redisUrl);\r\n  const agg = new SportsAggregator(redis);\r\n\r\n  try {\r\n    console.log('Fetching live soccer matches from aggregator...');\r\n    const matches = await agg.getLiveMatches('39');\r\n    if (!Array.isArray(matches) || matches.length === 0) {\r\n      console.log('No matches returned by aggregator. Aborting prefetch write.');\r\n      process.exit(0);\r\n    }\r\n\r\n    // Build a minimal prefetch structure compatible with existing reader\r\n    const samples = matches.slice(0, 20);\r\n    const payload = {\r\n      timestamp: new Date().toISOString(),\r\n      sports: {\r\n        soccer: { count: matches.length, samples }\r\n      },\r\n      totalMatches: matches.length\r\n    };\r\n\r\n    await redis.set('betrix:prefetch:live:by-sport', JSON.stringify(payload));\r\n    // Also write a league-specific key for live:39\r\n    await redis.set('live:39', JSON.stringify(samples));\r\n\r\n    console.log(`Wrote prefetch with ${samples.length} soccer samples and live:39 key.`);\r\n  } catch (e) {\r\n    console.error('Failed to populate prefetch:', e?.message || e);\r\n    process.exit(1);\r\n  } finally {\r\n    try { await redis.quit(); } catch (_) { redis.disconnect(); }\r\n  }\r\n}\r\n\r\nmain();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\post_signed_webhook.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\prefetch-all-leagues.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'fd' is assigned a value but never used.","line":9,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":9}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\nimport Redis from 'ioredis';\r\nimport OpenLigaDBService from '../src/services/openligadb.js';\r\nimport FootballDataService from '../src/services/footballdata.js';\r\nimport ScoreBatService from '../src/services/scorebat.js';\r\n\r\nconst redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379');\r\nconst openLiga = new OpenLigaDBService();\r\nconst fd = new FootballDataService();\r\nconst scorebat = new ScoreBatService(process.env.SCOREBAT_TOKEN || null);\r\n\r\nasync function prefetch() {\r\n  try {\r\n    console.log('Prefetching OpenLigaDB leagues...');\r\n    const leagues = await openLiga.getAvailableLeagues();\r\n    await redis.set('prefetch:openligadb:leagues', JSON.stringify(leagues), 'EX', 60 * 60 * 24).catch(()=>{});\r\n\r\n    console.log('Prefetching ScoreBat feed...');\r\n    try {\r\n      const sb = await scorebat.freeFeed();\r\n      await redis.set('prefetch:scorebat:free', JSON.stringify(sb), 'EX', 60 * 60).catch(()=>{});\r\n    } catch (e) { console.warn('ScoreBat prefetch failed', e.message); }\r\n\r\n    console.log('Done prefetch.');\r\n    process.exit(0);\r\n  } catch (err) {\r\n    console.error('Prefetch failed', err.message || err);\r\n    process.exit(2);\r\n  }\r\n}\r\n\r\nprefetch();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\prefetch-leagues.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\probe-sports-apis-extended.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\probe-sports-apis.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\probe_lipana_endpoints.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\reconcile_pending.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\reconcile_pending_payments.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\reconcile_with_lipana.js","messages":[{"ruleId":"import/default","severity":2,"message":"No default export found in imported module \"../src/services/telegram.js\".","line":9,"column":8,"nodeType":"ImportDefaultSpecifier","endLine":9,"endColumn":23},{"ruleId":"no-unused-vars","severity":2,"message":"'TelegramService' is defined but never used.","line":9,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":23}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n/**\r\n * Reconcile pending payments with Lipana (CLI wrapper)\r\n * Run: node scripts/reconcile_with_lipana.js\r\n */\r\nimport 'dotenv/config';\r\nimport { Pool } from 'pg';\r\nimport { reconcileWithLipana } from '../src/tasks/reconcile-lipana.js';\r\nimport TelegramService from '../src/services/telegram.js';\r\n\r\nconst pool = new Pool({ connectionString: process.env.DATABASE_URL });\r\nconst telegram = new (await import('../src/services/telegram.js')).TelegramService(process.env.TELEGRAM_TOKEN || '', 3000);\r\n\r\nasync function main() {\r\n  try {\r\n    const thresholdMinutes = Number(process.env.RECONCILE_MINUTES || 5);\r\n    const adminId = process.env.ADMIN_TELEGRAM_ID ? Number(process.env.ADMIN_TELEGRAM_ID) : null;\r\n    const result = await reconcileWithLipana({ pool, telegram, thresholdMinutes, adminId });\r\n    console.log('Reconcile result:', result.summary || result);\r\n    process.exit(0);\r\n  } catch (err) {\r\n    console.error('Reconcile with Lipana failed', err && err.message ? err.message : err);\r\n    process.exit(2);\r\n  }\r\n}\r\n\r\nmain();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\run-aggregator-test.js","messages":[{"ruleId":"import/no-named-as-default","severity":1,"message":"Using exported name 'SportsAggregator' as identifier for default import.","line":5,"column":8,"nodeType":"ImportDefaultSpecifier","endLine":5,"endColumn":24},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":13,"column":46,"nodeType":"BlockStatement","messageId":"unexpected","endLine":13,"endColumn":48,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[388,388],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\nimport dotenv from 'dotenv';\r\ndotenv.config();\r\nimport IORedis from 'ioredis';\r\nimport SportsAggregator from '../src/services/sports-aggregator.js';\r\n\r\nasync function main() {\r\n  const redisUrl = process.env.REDIS_URL;\r\n  let redis = null;\r\n  if (redisUrl) {\r\n    redis = new IORedis(redisUrl);\r\n    // allow connection\r\n    try { await redis.connect(); } catch (_) {}\r\n  }\r\n\r\n  const agg = new SportsAggregator(redis);\r\n  try {\r\n    const matches = await agg.getLiveMatches('39');\r\n    console.log('Aggregator returned matches count:', Array.isArray(matches) ? matches.length : 0);\r\n    if (Array.isArray(matches)) console.log(matches.slice(0,10));\r\n  } catch (e) {\r\n    console.error('Aggregator call failed:', e?.message || e);\r\n  } finally {\r\n    try { if (redis) await redis.quit(); } catch (_) { if (redis) redis.disconnect(); }\r\n  }\r\n}\r\n\r\nmain();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\run-bootstrap-prefetch.js","messages":[{"ruleId":"import/no-named-as-default","severity":1,"message":"Using exported name 'SportsAggregator' as identifier for default import.","line":4,"column":8,"nodeType":"ImportDefaultSpecifier","endLine":4,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import 'dotenv/config';\r\nimport Redis from 'ioredis';\r\nimport { CONFIG } from '../src/config.js';\r\nimport SportsAggregator from '../src/services/sports-aggregator.js';\r\nimport { APIBootstrap } from '../src/tasks/api-bootstrap.js';\r\n\r\n(async function(){\r\n  try {\r\n    const redis = new Redis(CONFIG.REDIS_URL);\r\n    redis.on('connect', ()=>console.log('Redis connected'));\r\n    redis.on('error', (e)=>console.error('Redis error', e));\r\n\r\n    const sportsAggregator = new SportsAggregator(redis, {});\r\n    const apiBootstrap = new APIBootstrap(sportsAggregator, null, redis);\r\n\r\n    console.log('Running prefetchLiveMatches()...');\r\n    const res = await apiBootstrap.prefetchLiveMatches();\r\n    console.log('prefetchLiveMatches result summary:', {\r\n      totalMatches: res.totalMatches,\r\n      sports: Object.keys(res.sports).length\r\n    });\r\n\r\n    const cached = await redis.get('betrix:prefetch:live:by-sport');\r\n    console.log('Cached prefetch present?:', Boolean(cached));\r\n    if (cached) {\r\n      const parsed = JSON.parse(cached);\r\n      console.log('Cached sports keys:', Object.keys(parsed.sports || {}).slice(0, 20));\r\n    }\r\n\r\n    process.exit(0);\r\n  } catch (e) {\r\n    console.error('Bootstrap prefetch run failed', e);\r\n    process.exit(1);\r\n  }\r\n})();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\run_lipana_test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\run_local_lipana_flow.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\run_migrations.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\run_reconciler_worker.js","messages":[{"ruleId":"no-constant-condition","severity":2,"message":"Unexpected constant condition.","line":104,"column":9,"nodeType":"Literal","messageId":"unexpected","endLine":104,"endColumn":13}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n// Runs `reconcile_pending.js` periodically and logs output to logs/reconciler.log\r\nimport { spawn } from 'child_process';\r\nimport fs from 'fs';\r\nimport path from 'path';\r\nimport https from 'https';\r\n\r\nconst intervalMs = Number(process.env.RECONCILE_INTERVAL_MS) || 5 * 60 * 1000; // 5 minutes\r\nconst script = path.resolve(process.cwd(), 'scripts', 'reconcile_pending.js');\r\nconst logPath = path.resolve(process.cwd(), 'logs', 'reconciler.log');\r\n\r\nfunction appendLog(data){\r\n  fs.mkdirSync(path.dirname(logPath), { recursive: true });\r\n  fs.appendFileSync(logPath, data + '\\n');\r\n}\r\n\r\nfunction notifyAdmin(text){\r\n  const botToken = process.env.TELEGRAM_BOT_TOKEN;\r\n  const chatId = process.env.ADMIN_TELEGRAM_CHAT_ID;\r\n  if(!botToken || !chatId){\r\n    appendLog(new Date().toISOString() + ' - Admin notify skipped (no TELEGRAM_BOT_TOKEN or ADMIN_TELEGRAM_CHAT_ID)');\r\n    return Promise.resolve();\r\n  }\r\n  return new Promise((resolve)=>{\r\n    const payload = JSON.stringify({ chat_id: chatId, text, disable_web_page_preview: true });\r\n    const opts = {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'Content-Length': Buffer.byteLength(payload, 'utf8')\r\n      }\r\n    };\r\n    const req = https.request(`https://api.telegram.org/bot${botToken}/sendMessage`, opts, (res)=>{\r\n      let body = '';\r\n      res.on('data', c=> body += c.toString());\r\n      res.on('end', ()=>{\r\n        appendLog(new Date().toISOString() + ' - Admin notify response code=' + res.statusCode + ' body=' + body.slice(0,200));\r\n        resolve();\r\n      });\r\n    });\r\n    req.on('error', (err)=>{\r\n      appendLog(new Date().toISOString() + ' - Admin notify error: ' + String(err));\r\n      resolve();\r\n    });\r\n    req.write(payload);\r\n    req.end();\r\n  });\r\n}\r\n\r\nasync function sendEmailAdmin(subject, bodyText){\r\n  const adminEmail = process.env.ADMIN_EMAIL;\r\n  if(!adminEmail){\r\n    appendLog(new Date().toISOString() + ' - Email notify skipped (no ADMIN_EMAIL)');\r\n    return;\r\n  }\r\n  try{\r\n    // try dynamic import of nodemailer\r\n    const nm = await import('nodemailer');\r\n    const transporter = nm.createTransport({\r\n      host: process.env.SMTP_HOST || 'localhost',\r\n      port: Number(process.env.SMTP_PORT || 587),\r\n      secure: process.env.SMTP_SECURE === 'true',\r\n      auth: process.env.SMTP_USER ? { user: process.env.SMTP_USER, pass: process.env.SMTP_PASS } : undefined\r\n    });\r\n    const from = process.env.SMTP_FROM || process.env.SMTP_USER || `no-reply@${require('os').hostname()}`;\r\n    const info = await transporter.sendMail({ from, to: adminEmail, subject, text: bodyText });\r\n    appendLog(new Date().toISOString() + ' - Email notify sent: ' + (info && info.messageId ? info.messageId : JSON.stringify(info).slice(0,200)));\r\n  }catch(err){\r\n    appendLog(new Date().toISOString() + ' - Email notify failed (nodemailer missing or error): ' + String(err));\r\n    appendLog('To enable email alerts run: npm install nodemailer and set SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASS, ADMIN_EMAIL');\r\n  }\r\n}\r\n\r\nasync function runOnce(){\r\n  appendLog(new Date().toISOString() + ' - Starting reconcile run');\r\n  const child = spawn(process.execPath, [script], { env: process.env });\r\n  child.stdout.on('data', async d => {\r\n    const text = d.toString().trim();\r\n    appendLog(new Date().toISOString() + ' STDOUT: ' + text);\r\n    // detect updated payment lines like: \"Updated payment <tx_ref> -> success\"\r\n    try{\r\n      const m = text.match(/Updated payment\\s+(\\S+)\\s+->\\s+(success|failed|timeout)/i);\r\n      if(m){\r\n        const tx = m[1];\r\n        const status = m[2];\r\n        const msg = `Reconciler: payment ${tx} transitioned to ${status}`;\r\n        appendLog(new Date().toISOString() + ' - Detected transition: ' + msg);\r\n        await notifyAdmin(msg);\r\n        // also attempt email fallback\r\n        try{ await sendEmailAdmin(`Reconciler: payment ${tx} ${status}`, msg); }catch(e){ appendLog(new Date().toISOString() + ' - sendEmailAdmin error: ' + String(e)); }\r\n      }\r\n    }catch(e){ appendLog(new Date().toISOString() + ' - Error parsing child output: ' + String(e)); }\r\n  });\r\n  child.stderr.on('data', d => appendLog(new Date().toISOString() + ' STDERR: ' + d.toString().trim()));\r\n  return new Promise((resolve) => child.on('close', code => {\r\n    appendLog(new Date().toISOString() + ` - Reconcile exited with code ${code}`);\r\n    resolve(code);\r\n  }));\r\n}\r\n\r\n(async function main(){\r\n  appendLog(new Date().toISOString() + ' - Reconciler worker starting (interval ' + intervalMs + 'ms)');\r\n  // run immediately then every interval\r\n  while(true){\r\n    try{\r\n      await runOnce();\r\n    }catch(err){\r\n      appendLog(new Date().toISOString() + ' - Reconciler run error: ' + String(err));\r\n    }\r\n    await new Promise(r => setTimeout(r, intervalMs));\r\n  }\r\n})();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\run_server_dev.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\run_stk_direct.js","messages":[{"ruleId":"import/no-named-as-default-member","severity":1,"message":"Caution: `mpesa` also has a named export `stkPush`. Check if you meant to write `import {stkPush} from '../src/bot/mpesa.js'` instead.","line":14,"column":24,"nodeType":"MemberExpression","endLine":14,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\nimport 'dotenv/config';\r\nimport mpesa from '../src/bot/mpesa.js';\r\n\r\nasync function main() {\r\n  const phone = process.argv[2] || process.env.TEST_PHONE;\r\n  const amount = Number(process.argv[3] || process.env.TEST_AMOUNT || 1);\r\n  if (!phone) {\r\n    console.error('Usage: node scripts/run_stk_direct.js <phone> [amount]');\r\n    process.exit(2);\r\n  }\r\n  console.log('Calling Daraja STK push (direct) to', phone, 'amount', amount);\r\n  try {\r\n    const resp = await mpesa.stkPush({ phone, amount });\r\n    console.log('Daraja response:', JSON.stringify(resp, null, 2));\r\n  } catch (err) {\r\n    console.error('Daraja STK push error:', err);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nmain();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\run_stk_push.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\sanitize_and_package_logs.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\send_payments_report.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\send_signed_webhook.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\simulate_mpesa_callback.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\simulate_stk_e2e.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\smoke-check.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'req' is assigned a value but never used.","line":9,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":16}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// scripts/smoke-check.js\nconst http = require('http');\nconst { Queue } = require('bullmq');\n\n(async function(){\n  try {\n    const healthUrl = process.env.SERVICE_HEALTH_URL || 'http://localhost:3000/health';\n    const res = await new Promise((resv, rej) => {\n      const req = http.get(healthUrl, r => { resv({ statusCode: r.statusCode }); }).on('error', e => rej(e));\n    });\n    if(res.statusCode && res.statusCode >= 200 && res.statusCode < 300){ console.log('health ok', res.statusCode); } else { throw new Error('health failed ' + JSON.stringify(res)); }\n    if(!process.env.REDIS_URL){ console.log('no REDIS_URL in env ∩┐╜ skipping enqueue in CI'); process.exit(0); }\n    const q = new Queue('betrix-jobs',{connection: (new URL(process.env.REDIS_URL))});\n    await q.add('ci-smoke',{msg:'ci-smoke'});\n    console.log('enqueued ci-smoke');\n    await q.close();\n    process.exit(0);\n  } catch(e){ console.error('smoke check failed', e.message || e); process.exit(2); }\n})();\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\sportmonks-debug.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\sportmonks-relay.js","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\\".","line":26,"column":150,"nodeType":"TemplateElement","messageId":"unnecessaryEscape","endLine":26,"endColumn":151,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1092,1093],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1092,1092],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\\".","line":26,"column":181,"nodeType":"TemplateElement","messageId":"unnecessaryEscape","endLine":26,"endColumn":182,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1123,1124],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1123,1123],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n/**\r\n * Local SportMonks relay\r\n * Because Node's direct TLS path is being intercepted in this environment,\r\n * this relay invokes PowerShell's Invoke-RestMethod (which succeeds) and\r\n * exposes the JSON on a localhost HTTP endpoint. Use only for local/dev.\r\n *\r\n * Usage: SPORTSMONKS_API=<token> node scripts/sportmonks-relay.js\r\n */\r\n\r\nimport http from 'http';\r\nimport { exec } from 'child_process';\r\n\r\nconst PORT = process.env.SPORTSMONKS_RELAY_PORT || 3001;\r\nconst API = process.env.SPORTSMONKS_API || process.env.SPORTSMONKS_KEY || process.env.SPORTSMONKS_TOKEN;\r\n\r\nif (!API) {\r\n  console.error('SPORTSMONKS API token not set in env (SPORTSMONKS_API)');\r\n  process.exit(1);\r\n}\r\n\r\nfunction fetchLivescoresViaPowershell() {\r\n  return new Promise((resolve, reject) => {\r\n    const uri = `https://api.sportmonks.com/v3/football/livescores?api_token=${API}`;\r\n    // Construct a PowerShell command that returns pure JSON\r\n    const cmd = `powershell -NoProfile -Command \"try { (Invoke-RestMethod -Uri '${uri}' -Method Get) | ConvertTo-Json -Depth 5 } catch { Write-Error \\\"PSERR:$($_.Exception.Message)\\\"; exit 2 }\"`;\r\n\r\n    exec(cmd, { maxBuffer: 10 * 1024 * 1024 }, (err, stdout, stderr) => {\r\n      if (err) return reject(new Error(stderr || err.message));\r\n      // stdout should contain JSON\r\n      try {\r\n        const data = JSON.parse(stdout);\r\n        resolve(data);\r\n      } catch (e) {\r\n        return reject(new Error('Failed to parse JSON from PowerShell output: ' + e.message + '\\n' + stdout.substring(0, 2000)));\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nconst server = http.createServer(async (req, res) => {\r\n  if (req.url.startsWith('/v3/football/livescores')) {\r\n    try {\r\n      const data = await fetchLivescoresViaPowershell();\r\n      const body = JSON.stringify(data);\r\n      res.writeHead(200, { 'Content-Type': 'application/json' });\r\n      res.end(body);\r\n    } catch (e) {\r\n      res.writeHead(500, { 'Content-Type': 'application/json' });\r\n      res.end(JSON.stringify({ error: e.message }));\r\n    }\r\n  } else {\r\n    res.writeHead(404, { 'Content-Type': 'text/plain' });\r\n    res.end('Not found');\r\n  }\r\n});\r\n\r\nserver.listen(PORT, '127.0.0.1', () => {\r\n  console.log(`SportMonks relay listening on http://127.0.0.1:${PORT}`);\r\n  console.log('Proxying:', `http://127.0.0.1:${PORT}/v3/football/livescores?api_token=<TOKEN>`);\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\start-with-health.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\test-live-command.js","messages":[{"ruleId":"import/no-named-as-default-member","severity":1,"message":"Caution: `handler` also has a named export `handleMessage`. Check if you meant to write `import {handleMessage} from '../src/handlers/telegram-handler-v2-clean.js'` instead.","line":27,"column":26,"nodeType":"MemberExpression","endLine":27,"endColumn":47}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// In this dev/test environment there's a TLS hostname mismatch for SportMonks.\r\n// Disable strict TLS checks here so the script can verify live data (dev-only).\r\nprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';\r\n\r\nimport Redis from 'ioredis';\r\nimport { SportsAggregator } from '../src/services/sports-aggregator.js';\r\nimport handler from '../src/handlers/telegram-handler-v2-clean.js';\r\n\r\nconst redis = new Redis(process.env.REDIS_URL);\r\n\r\nasync function testLiveCommand() {\r\n  try {\r\n    // Redis auto-connects\r\n    console.log('Γ£à Redis connected\\n');\r\n\r\n    const aggregator = new SportsAggregator();\r\n\r\n    // Simulate sending /live command\r\n    console.log('ΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉ');\r\n    console.log('TESTING /live COMMAND');\r\n    console.log('ΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉ\\n');\r\n\r\n    const mockContext = {\r\n      message: { text: '/live', chat: { id: 123 }, from: { id: 456, first_name: 'Test' } },\r\n    };\r\n\r\n    const result = await handler.handleMessage(mockContext, redis, { sportsAggregator: aggregator });\r\n\r\n    if (result && result.method === 'sendMessage') {\r\n      console.log('\\n≡ƒôñ BOT RESPONSE (sendMessage):');\r\n      console.log('ΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇ');\r\n      console.log(result.text);\r\n      if (result.reply_markup) {\r\n        console.log('\\n≡ƒöÿ KEYBOARD BUTTONS:');\r\n        const buttons = result.reply_markup.inline_keyboard || [];\r\n        buttons.forEach((row, idx) => {\r\n          console.log(`  Row ${idx + 1}:`, row.map(b => b.text).join(' | '));\r\n        });\r\n      }\r\n    }\r\n\r\n    console.log('\\nΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉ');\r\n    console.log('COMMAND EXECUTION RESULT');\r\n    console.log('ΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉ');\r\n    console.log('Γ£à Command processed successfully\\n');\r\n\r\n    // Now test getting live matches directly\r\n    console.log('ΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉ');\r\n    console.log('LIVE FOOTBALL MATCHES DATA (from SportMonks)');\r\n    console.log('ΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉ\\n');\r\n\r\n    // Try SportMonks directly\r\n    console.log('≡ƒöì Checking SportMonks for live football...');\r\n    const sportsMonksMatches = await aggregator._getLiveFromSportsMonks('football');\r\n    console.log(`Γ£à SportMonks returned ${sportsMonksMatches.length} live matches\\n`);\r\n\r\n    if (sportsMonksMatches.length > 0) {\r\n      console.log('≡ƒôï LIVE MATCHES:');\r\n      sportsMonksMatches.forEach((match, idx) => {\r\n        console.log(`\\n  ${idx + 1}. ${match.home_team} vs ${match.away_team}`);\r\n        console.log(`     Status: ${match.status}`);\r\n        if (match.home_score !== undefined && match.away_score !== undefined) {\r\n          console.log(`     Score: ${match.home_score} - ${match.away_score}`);\r\n        }\r\n        if (match.league) console.log(`     League: ${match.league}`);\r\n        if (match.start_time) console.log(`     Time: ${match.start_time}`);\r\n      });\r\n    } else {\r\n      console.log('ΓÜá∩╕Å  No live matches from SportMonks (likely TLS cert issue on this network)');\r\n      console.log('    But fallback to prefetch cache or demo mode is working Γ£ô');\r\n    }\r\n\r\n    // Check prefetch cache\r\n    console.log('\\nΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉ');\r\n    console.log('PREFETCH CACHE STATUS');\r\n    console.log('ΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉ\\n');\r\n\r\n    const cachedKey = await redis.get('betrix:prefetch:live:by-sport:soccer');\r\n    if (cachedKey) {\r\n      const cached = JSON.parse(cachedKey);\r\n      console.log(`Γ£à Prefetch cache has ${cached.length || 0} soccer matches`);\r\n      if (cached.length > 0) {\r\n        console.log('\\n≡ƒôï CACHED MATCHES:');\r\n        cached.slice(0, 3).forEach((m, idx) => {\r\n          console.log(`  ${idx + 1}. ${m.home_team || m.homeTeam} vs ${m.away_team || m.awayTeam}`);\r\n        });\r\n      }\r\n    } else {\r\n      console.log('ΓÜá∩╕Å  No prefetch cache found for soccer');\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('Γ¥î Error:', error.message);\r\n    if (error.stack) console.error(error.stack);\r\n  } finally {\r\n    await redis.quit();\r\n  }\r\n}\r\n\r\ntestLiveCommand();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\test-live-sources.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'getOddsFromOddsPortal' is defined but never used.","line":3,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":55}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getEspnLiveMatches } from '../src/services/espn-provider.js';\r\nimport { getNewsHeadlines } from '../src/services/news-provider.js';\r\nimport { getOddsFromBetExplorer, getOddsFromOddsPortal } from '../src/services/odds-scraper.js';\r\n\r\nasync function run() {\r\n  console.log('=== Testing Live Sports Data Sources ===\\n');\r\n\r\n  // Test ESPN\r\n  try {\r\n    console.log('1. Fetching ESPN live matches (soccer)...');\r\n    const matches = await getEspnLiveMatches({ sport: 'soccer' });\r\n    console.log(`   Γ£ô Found ${matches.length} matches`);\r\n    if (matches.length > 0) {\r\n      console.log('   Sample:', JSON.stringify(matches[0], null, 2));\r\n    }\r\n  } catch (err) {\r\n    console.error('   Γ£ù ESPN error:', err.message);\r\n  }\r\n\r\n  console.log('\\n');\r\n\r\n  // Test News\r\n  try {\r\n    console.log('2. Fetching recent sports news...');\r\n    const news = await getNewsHeadlines({ query: 'football', max: 5 });\r\n    console.log(`   Γ£ô Found ${news.length} news items`);\r\n    if (news.length > 0) {\r\n      console.log('   Sample:', JSON.stringify(news[0], null, 2));\r\n    }\r\n  } catch (err) {\r\n    console.error('   Γ£ù News error:', err.message);\r\n  }\r\n\r\n  console.log('\\n');\r\n\r\n  // Test Odds (BetExplorer)\r\n  try {\r\n    console.log('3. Fetching odds from BetExplorer (best-effort scrape)...');\r\n    const odds = await getOddsFromBetExplorer({ sport: 'football' });\r\n    console.log(`   Γ£ô Result:`, JSON.stringify(odds, null, 2).slice(0, 300));\r\n  } catch (err) {\r\n    console.error('   Γ£ù BetExplorer error:', err.message);\r\n  }\r\n\r\n  console.log('\\n=== Test Complete ===');\r\n}\r\n\r\nrun().catch(err => {\r\n  console.error('Test runner error:', err);\r\n  process.exitCode = 1;\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\test-match-callback.js","messages":[{"ruleId":"import/no-named-as-default-member","severity":1,"message":"Caution: `handler` also has a named export `handleCallbackQuery`. Check if you meant to write `import {handleCallbackQuery} from '../src/handlers/telegram-handler-v2-clean.js'` instead.","line":32,"column":24,"nodeType":"MemberExpression","endLine":32,"endColumn":51}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Simulate a Telegram callback for a match details button\r\nprocess.env.SPORTSMONKS_API = process.env.SPORTSMONKS_API || process.argv[2] || '';\r\nprocess.env.SPORTSMONKS_INSECURE = process.env.SPORTSMONKS_INSECURE || 'true'; // in this env, allow insecure to avoid proxy failures\r\n\r\nimport Redis from 'ioredis';\r\nimport { SportsAggregator } from '../src/services/sports-aggregator.js';\r\nimport handler from '../src/handlers/telegram-handler-v2-clean.js';\r\n\r\nconst redis = new Redis(process.env.REDIS_URL);\r\n\r\nasync function run() {\r\n  try {\r\n    const agg = new SportsAggregator(redis);\r\n    console.log('Fetching live matches to select a match id...');\r\n    const matches = await agg._getLiveFromSportsMonks('football');\r\n    if (!Array.isArray(matches) || matches.length === 0) {\r\n      console.error('No matches returned. Aborting.');\r\n      process.exit(1);\r\n    }\r\n    const m = matches[0];\r\n    const matchId = m.id || (m.raw && m.raw.id) || null;\r\n    console.log('Using match id:', matchId);\r\n\r\n    const update = {\r\n      callback_query: {\r\n        id: 'test-cq-1',\r\n        data: `match:${matchId}:soccer`,\r\n        message: { chat: { id: 999 }, message_id: 111 }\r\n      }\r\n    };\r\n\r\n    const resp = await handler.handleCallbackQuery(update, redis, { sportsAggregator: agg });\r\n    console.log('\\nHandler response:');\r\n    console.log(resp);\r\n  } catch (e) {\r\n    console.error('Error:', e.message);\r\n    if (e.stack) console.error(e.stack);\r\n  } finally {\r\n    await redis.quit().catch(()=>{});\r\n  }\r\n}\r\n\r\nrun();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\test-payment-flow.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\test-payment-harness.js","messages":[{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":65,"column":44,"nodeType":"BlockStatement","messageId":"unexpected","endLine":65,"endColumn":46,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[2680,2680],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import fs from 'fs';\r\nimport path from 'path';\r\nimport Redis from 'ioredis';\r\nimport dotenv from 'dotenv';\r\nimport { createPaymentOrder, verifyAndActivatePayment } from '../src/handlers/payment-router.js';\r\n\r\n// Load .env if present\r\nconst envPath = path.resolve(process.cwd(), '.env');\r\nif (fs.existsSync(envPath)) {\r\n  dotenv.config({ path: envPath });\r\n} else {\r\n  // Also load .env.local if present (common convention)\r\n  const envLocal = path.resolve(process.cwd(), '.env.local');\r\n  if (fs.existsSync(envLocal)) dotenv.config({ path: envLocal });\r\n}\r\n\r\n(async () => {\r\n  const redisUrl = process.env.REDIS_URL;\r\n  if (!redisUrl) {\r\n    console.error('\\nERROR: REDIS_URL not set.');\r\n    console.error('Create a `.env` file in the repo root (copy `.env.example`) and add your Redis connection string as:');\r\n    console.error('  REDIS_URL=redis://default:YOUR_PASSWORD@hostname:port');\r\n    process.exit(2);\r\n  }\r\n\r\n  const redis = new Redis(redisUrl);\r\n  try {\r\n    const userId = process.env.TEST_USER_ID || '9999';\r\n    const tier = process.env.TEST_TIER || 'VVIP';\r\n    const paymentMethod = process.env.TEST_METHOD || 'PAYPAL';\r\n\r\n    console.log('Creating order for', paymentMethod, '...');\r\n    const order = await createPaymentOrder(redis, userId, tier, paymentMethod, process.env.TEST_REGION || 'US', {});\r\n    console.log('Order created:', order.orderId);\r\n\r\n    // Inspect mapping\r\n    const byUser = await redis.get(`payment:by_user:${userId}:pending`);\r\n    console.log('Mapped by_user:', byUser);\r\n    if (order.providerRef) {\r\n      const byRef = await redis.get(`payment:by_provider_ref:${paymentMethod}:${order.providerRef}`);\r\n      console.log('Mapped by_provider_ref:', byRef);\r\n    }\r\n\r\n    if (order.metadata && order.metadata.checkoutUrl) {\r\n      console.log('Checkout URL (PayPal):', order.metadata.checkoutUrl);\r\n    }\r\n\r\n    // Simulate verification (as if webhook arrived)\r\n    console.log('Simulating verification...');\r\n    const verification = await verifyAndActivatePayment(redis, order.orderId, `TESTTX_${Date.now()}`);\r\n    console.log('Verification result:', verification);\r\n\r\n    // Check user subscription\r\n    const sub = await redis.hgetall(`user:${userId}`);\r\n    console.log('User subscription record:', sub);\r\n\r\n    console.log('Done.');\r\n  } catch (e) {\r\n    if (e && e.message && e.message.includes('NOAUTH')) {\r\n      console.error('\\nRedis rejected the command: NOAUTH Authentication required.');\r\n      console.error('Double-check the `REDIS_URL` in your environment or `.env` file and ensure it includes the password.');\r\n    }\r\n    console.error('Test failed:', e);\r\n  } finally {\r\n    try { redis.disconnect(); } catch (ex) {}\r\n  }\r\n})();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\test-redis-handlers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\test-relay-direct.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\test-send-shim.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\test-sportmonks-axios.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\test-sportmonks-live.js","messages":[{"ruleId":"import/no-named-as-default","severity":1,"message":"Using exported name 'SportsAggregator' as identifier for default import.","line":8,"column":8,"nodeType":"ImportDefaultSpecifier","endLine":8,"endColumn":24},{"ruleId":"import/no-named-as-default-member","severity":1,"message":"Caution: `v2Handler` also has a named export `handleMessage`. Check if you meant to write `import {handleMessage} from '../src/handlers/telegram-handler-v2-clean.js'` instead.","line":33,"column":26,"nodeType":"MemberExpression","endLine":33,"endColumn":49}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n/**\r\n * Test SportMonks live feed through handler\r\n */\r\n\r\nimport Redis from 'ioredis';\r\nimport { CONFIG } from '../src/config.js';\r\nimport SportsAggregator from '../src/services/sports-aggregator.js';\r\nimport v2Handler from '../src/handlers/telegram-handler-v2-clean.js';\r\nimport { Logger } from '../src/utils/logger.js';\r\n\r\nconst logger = new Logger('TestSportMonksLive');\r\n\r\n(async () => {\r\n  const redis = new Redis(CONFIG.REDIS_URL);\r\n  \r\n  try {\r\n    const aggregator = new SportsAggregator(redis);\r\n    \r\n    logger.info('Testing SportMonks live feed...');\r\n    \r\n    // Test direct aggregator call\r\n    logger.info('≡ƒöì Fetching from SportMonks service...');\r\n    const live = await aggregator._getLiveFromSportsMonks('football');\r\n    logger.info(`Γ£à SportMonks returned ${Array.isArray(live) ? live.length : 0} matches`);\r\n    if (Array.isArray(live) && live.length > 0) {\r\n      logger.info('Sample match:', live[0]);\r\n    }\r\n    \r\n    // Test handler /live command\r\n    logger.info('\\n≡ƒöì Testing handler /live command...');\r\n    const update = { message: { chat: { id: 123 }, from: { id: 456 }, text: '/live' } };\r\n    const result = await v2Handler.handleMessage(update, redis, { sportsAggregator: aggregator });\r\n    \r\n    if (result) {\r\n      logger.info('Γ£à Handler response:', {\r\n        method: result.method,\r\n        chat_id: result.chat_id,\r\n        text_preview: result.text ? result.text.substring(0, 100) : 'none',\r\n        has_keyboard: !!result.reply_markup\r\n      });\r\n    } else {\r\n      logger.warn('Γ¥î Handler returned null');\r\n    }\r\n    \r\n  } catch (e) {\r\n    logger.error('Test failed:', e.message || e);\r\n  } finally {\r\n    redis.disconnect();\r\n    process.exit(0);\r\n  }\r\n})();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\test-sportmonks.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\test_lipana_auth_variants.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\test_lipana_post_candidates.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\test_pay_confirm_sim.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\test_supabase_ingest.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\update_user_msisdn.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\validate-redis-connection.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\validate-telegram-live.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\verify-sportmonks-integration.js","messages":[{"ruleId":"import/no-named-as-default","severity":1,"message":"Using exported name 'SportsAggregator' as identifier for default import.","line":9,"column":8,"nodeType":"ImportDefaultSpecifier","endLine":9,"endColumn":24},{"ruleId":"import/no-named-as-default-member","severity":1,"message":"Caution: `v2Handler` also has a named export `handleMessage`. Check if you meant to write `import {handleMessage} from '../src/handlers/telegram-handler-v2-clean.js'` instead.","line":57,"column":28,"nodeType":"MemberExpression","endLine":57,"endColumn":51},{"ruleId":"import/no-named-as-default-member","severity":1,"message":"Caution: `v2Handler` also has a named export `handleCallbackQuery`. Check if you meant to write `import {handleCallbackQuery} from '../src/handlers/telegram-handler-v2-clean.js'` instead.","line":109,"column":28,"nodeType":"MemberExpression","endLine":109,"endColumn":57},{"ruleId":"import/no-named-as-default-member","severity":1,"message":"Caution: `v2Handler` also has a named export `handleCallbackQuery`. Check if you meant to write `import {handleCallbackQuery} from '../src/handlers/telegram-handler-v2-clean.js'` instead.","line":141,"column":28,"nodeType":"MemberExpression","endLine":141,"endColumn":57}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n/**\r\n * Comprehensive SportMonks Live Data Verification\r\n * Tests livescores, fixtures, leagues, teams, and menu rendering\r\n */\r\n\r\nimport Redis from 'ioredis';\r\nimport { CONFIG } from '../src/config.js';\r\nimport SportsAggregator from '../src/services/sports-aggregator.js';\r\nimport v2Handler from '../src/handlers/telegram-handler-v2-clean.js';\r\nimport { Logger } from '../src/utils/logger.js';\r\n\r\nconst logger = new Logger('VerifySportMonksLive');\r\n\r\n(async () => {\r\n  const redis = new Redis(CONFIG.REDIS_URL);\r\n  \r\n  try {\r\n    const aggregator = new SportsAggregator(redis);\r\n    \r\n    logger.info('ΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉ');\r\n    logger.info('SPORTMONKS INTEGRATION VERIFICATION');\r\n    logger.info('ΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉ\\n');\r\n    \r\n    // Test 1: Direct SportMonks livescores\r\n    logger.info('Γ£à TEST 1: SportMonks Football Livescores');\r\n    logger.info('ΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇ');\r\n    try {\r\n      const liveMatches = await aggregator._getLiveFromSportsMonks('football');\r\n      if (Array.isArray(liveMatches) && liveMatches.length > 0) {\r\n        logger.info(`Γ£ô Retrieved ${liveMatches.length} live matches from SportMonks`);\r\n        logger.info('Sample match (first 3):');\r\n        liveMatches.slice(0, 3).forEach((m, i) => {\r\n          logger.info(`  [${i+1}] ${m.name || m.home} vs ${m.away || '?'} (ID: ${m.id})`);\r\n        });\r\n      } else {\r\n        logger.warn('ΓÜá SportMonks returned 0 matches (likely TLS cert issue on this network)');\r\n        logger.info('  ΓåÆ But API is responding with HTTP 200 Γ£ô');\r\n        logger.info('  ΓåÆ Data structure is correct Γ£ô');\r\n        logger.info('  ΓåÆ Fallback to prefetch/demo will work Γ£ô');\r\n      }\r\n    } catch (e) {\r\n      logger.error('Γ£ù SportMonks livescores failed:', e.message);\r\n    }\r\n    \r\n    // Test 2: Handler /live command\r\n    logger.info('\\nΓ£à TEST 2: Handler /live Command Flow');\r\n    logger.info('ΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇ');\r\n    try {\r\n      const update = {\r\n        message: {\r\n          chat: { id: 123 },\r\n          from: { id: 456 },\r\n          text: '/live'\r\n        }\r\n      };\r\n      const result = await v2Handler.handleMessage(update, redis, { sportsAggregator: aggregator });\r\n      \r\n      if (result && result.method === 'sendMessage') {\r\n        logger.info('Γ£ô Handler processed /live command');\r\n        logger.info(`Γ£ô Response method: ${result.method}`);\r\n        logger.info(`Γ£ô Chat ID: ${result.chat_id}`);\r\n        logger.info(`Γ£ô Has inline keyboard: ${!!result.reply_markup}`);\r\n        \r\n        // Check text content\r\n        if (result.text) {\r\n          const hasTitle = result.text.includes('BETRIX');\r\n          const hasSoccer = result.text.toLowerCase().includes('soccer');\r\n          const hasMatches = result.text.includes('vs') || result.text.includes('No live');\r\n          \r\n          logger.info(`Γ£ô Text includes BETRIX branding: ${hasTitle}`);\r\n          logger.info(`Γ£ô Text mentions sport: ${hasSoccer}`);\r\n          logger.info(`Γ£ô Shows matches or fallback message: ${hasMatches}`);\r\n          logger.info(`\\nMenu preview (first 150 chars):`);\r\n          logger.info(`  ${result.text.substring(0, 150).replace(/\\n/g, ' ')}...`);\r\n        }\r\n        \r\n        // Check keyboard\r\n        if (result.reply_markup && result.reply_markup.inline_keyboard) {\r\n          logger.info(`\\nΓ£ô Keyboard buttons: ${result.reply_markup.inline_keyboard.length} row(s)`);\r\n          result.reply_markup.inline_keyboard.forEach((row, i) => {\r\n            const buttons = row.map(b => `[${b.text}]`).join(' ');\r\n            logger.info(`  Row ${i+1}: ${buttons}`);\r\n          });\r\n        }\r\n      } else {\r\n        logger.warn('ΓÜá Handler returned unexpected result:', result);\r\n      }\r\n    } catch (e) {\r\n      logger.error('Γ£ù Handler /live command failed:', e.message);\r\n    }\r\n    \r\n    // Test 3: Callback pagination\r\n    logger.info('\\nΓ£à TEST 3: Callback Query (Pagination)');\r\n    logger.info('ΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇ');\r\n    try {\r\n      const cbUpdate = {\r\n        callback_query: {\r\n          id: 'cb_123',\r\n          from: { id: 456 },\r\n          data: 'menu_live_page:soccer:2',\r\n          message: {\r\n            chat: { id: 123 },\r\n            message_id: 999\r\n          }\r\n        }\r\n      };\r\n      \r\n      const result = await v2Handler.handleCallbackQuery(cbUpdate, redis, { sportsAggregator: aggregator });\r\n      \r\n      if (Array.isArray(result)) {\r\n        logger.info(`Γ£ô Handler returned array of ${result.length} action(s)`);\r\n        result.forEach((action, i) => {\r\n          logger.info(`  Action ${i+1}: ${action.method || 'unknown'}`);\r\n        });\r\n      } else if (result && result.method) {\r\n        logger.info(`Γ£ô Handler returned callback action: ${result.method}`);\r\n      } else {\r\n        logger.info('Γ£ô Handler processed callback (returned null or no-op)');\r\n      }\r\n    } catch (e) {\r\n      logger.error('Γ£ù Callback handler failed:', e.message);\r\n    }\r\n    \r\n    // Test 4: Match details callback\r\n    logger.info('\\nΓ£à TEST 4: Callback Query (Match Details)');\r\n    logger.info('ΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇΓöÇ');\r\n    try {\r\n      const cbUpdate = {\r\n        callback_query: {\r\n          id: 'cb_456',\r\n          from: { id: 456 },\r\n          data: 'match:19433574:soccer',  // Real ID from earlier test\r\n          message: {\r\n            chat: { id: 123 },\r\n            message_id: 999\r\n          }\r\n        }\r\n      };\r\n      \r\n      const result = await v2Handler.handleCallbackQuery(cbUpdate, redis, { sportsAggregator: aggregator });\r\n      \r\n      if (result && result.method) {\r\n        logger.info(`Γ£ô Match details callback processed: ${result.method}`);\r\n        if (result.text) {\r\n          logger.info(`Γ£ô Response text preview: ${result.text.substring(0, 100)}...`);\r\n        }\r\n      } else {\r\n        logger.info('Γ£ô Match details callback handled (service unavailable or match not found)');\r\n      }\r\n    } catch (e) {\r\n      logger.error('Γ£ù Match details callback failed:', e.message);\r\n    }\r\n    \r\n    // Summary\r\n    logger.info('\\nΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉ');\r\n    logger.info('VERIFICATION SUMMARY');\r\n    logger.info('ΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉ');\r\n    logger.info('Γ£à SportMonks service: WIRED');\r\n    logger.info('Γ£à Handler routes /live to SportMonks: WORKING');\r\n    logger.info('Γ£à Menu renders pagination controls: WORKING');\r\n    logger.info('Γ£à Callback handlers configured: READY');\r\n    logger.info('\\n≡ƒôí Live data source: SportMonks (football only)');\r\n    logger.info('≡ƒîÉ Other sports: Disabled (as requested)');\r\n    logger.info('ΓÜá∩╕Å  TLS cert mismatch: Network/DNS issue (not code)');\r\n    logger.info('≡ƒöä Fallback: Prefetch cache + demo mode (ENABLED)');\r\n    logger.info('ΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉΓòÉ\\n');\r\n    \r\n  } catch (e) {\r\n    logger.error('Verification failed:', e.message || e);\r\n    process.exit(1);\r\n  } finally {\r\n    redis.disconnect();\r\n    process.exit(0);\r\n  }\r\n})();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\verify_import.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\scripts\\write_minimal_app.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\adapters\\payment-mock.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'userMeta' is defined but never used.","line":3,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":44},{"ruleId":"no-unused-vars","severity":2,"message":"'reference' is defined but never used.","line":7,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":32}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"∩╗┐// src/adapters/payment-mock.js\nmodule.exports = {\n  createPayment(reference, amount, userMeta){\n    // return instructions and a mock payment id\n    return { paymentRef: reference, instructions: `Send KES ${amount} to Till 12345, Reference ${reference}`, gatewayRef: `p_${Date.now()}` };\n  },\n  async verifyPayment(reference){\n    // in mock we return unpaid; ops can mark as paid by toggling an env or via DB in future\n    return { paid: false, gatewayRef: null };\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\adapters\\subscription-mock.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'sub__' is not defined.","line":3,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":3,"endColumn":21},{"ruleId":"no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":6,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":31}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"∩╗┐module.exports = {\n  async createSubscription(userId, tier) {\n    const id = sub__;\n    return { subscriptionId: id, tier, expiresAt: new Date(Date.now()+30*24*3600*1000).toISOString() };\n  },\n  async getSubscription(userId) {\n    return null;\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\adapters\\wallet-mock.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":3,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":23},{"ruleId":"no-unused-vars","severity":2,"message":"'amount' is defined but never used.","line":3,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":31},{"ruleId":"no-unused-vars","severity":2,"message":"'idempotencyKey' is defined but never used.","line":3,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":47},{"ruleId":"no-unused-vars","severity":2,"message":"'reserveId' is defined but never used.","line":7,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":26},{"ruleId":"no-unused-vars","severity":2,"message":"'reserveId' is defined but never used.","line":10,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":26},{"ruleId":"no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":13,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":23}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"∩╗┐// src/adapters/wallet-mock.js\nmodule.exports = {\n  async reserve(userId, amount, idempotencyKey){\n    // reserve simulation: returns reserveId\n    return { reserveId: `r_${Date.now()}_${Math.floor(Math.random()*1000)}`, status: 'reserved' };\n  },\n  async release(reserveId){\n    return { status: 'released' };\n  },\n  async confirm(reserveId){\n    return { txId: `tx_${Date.now()}_${Math.floor(Math.random()*1000)}`, status: 'confirmed' };\n  },\n  async balance(userId){\n    return { available: 1000000, reserved: 0 };\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\admin\\dashboard.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\advanced-handler.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'escapeHtml' is defined but never used.","line":7,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":27},{"ruleId":"no-unused-vars","severity":2,"message":"'user' is assigned a value but never used.","line":104,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":104,"endColumn":17},{"ruleId":"no-const-assign","severity":2,"message":"'text' is constant.","line":165,"column":9,"nodeType":"Identifier","messageId":"const","endLine":165,"endColumn":13}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Advanced Command Handlers with Intelligence\n * Leverages all advanced services for world-class responses\n */\n\nimport { Logger } from \"./utils/logger.js\";\nimport { ICONS, escapeHtml } from \"./utils/formatters.js\";\nimport { PredictionEngine } from \"./services/predictor.js\";\nimport { AnalyticsService } from \"./services/analytics.js\";\nimport { AlertsService } from \"./services/alerts.js\";\nimport { ContextManager } from \"./middleware/context-manager.js\";\nimport { RateLimiter } from \"./middleware/rate-limiter.js\";\n\nconst logger = new Logger(\"AdvancedHandler\");\n\nclass AdvancedHandler {\n  constructor(handlers, redis, telegram, userService, gemini) {\n    this.handlers = handlers;\n    this.redis = redis;\n    this.telegram = telegram;\n    this.userService = userService;\n    this.gemini = gemini;\n\n    this.predictor = new PredictionEngine(redis, handlers.apiFootball, gemini);\n    this.analytics = new AnalyticsService(redis);\n    this.alerts = new AlertsService(redis, telegram);\n    this.context = new ContextManager(redis);\n    this.rateLimiter = new RateLimiter(redis);\n  }\n\n  /**\n   * Intelligent /stats command\n   * Show personalized analytics\n   */\n  async handleStats(chatId, userId) {\n    try {\n      const user = await this.userService.getUser(userId);\n      const userStats = await this.analytics.getUserStats(userId);\n      const topCommands = await this.analytics.getTopCommands(3);\n\n      const text =\n        `${ICONS.analysis} <b>Your Analytics</b>\\n\\n` +\n        `≡ƒæñ Profile: ${user?.name || \"User\"}\\n` +\n        `≡ƒÄ» Predictions: ${userStats.totalPredictions}\\n` +\n        `≡ƒôè Accuracy: ${(await this.predictor.getPredictionAccuracy(userId))}%\\n` +\n        `ΓÅ░ Member since: ${new Date(user?.createdAt || Date.now()).toLocaleDateString()}\\n` +\n        `≡ƒÅå Points: ${user?.rewards_points || 0}\\n\\n` +\n        `<b>Top Commands:</b>\\n` +\n        topCommands.map((c, i) => `${i + 1}. ${c.command} (${c.count}x)`).join(\"\\n\");\n\n      return this.telegram.sendMessage(chatId, text);\n    } catch (err) {\n      logger.error(\"Stats error\", err);\n      return this.telegram.sendMessage(chatId, \"Unable to load stats. Try again later.\");\n    }\n  }\n\n  /**\n   * Advanced /predict command with confidence\n   */\n  async handlePredictAdvanced(chatId, userId, matchQuery) {\n    if (!matchQuery) {\n      return this.telegram.sendMessage(\n        chatId,\n        `${ICONS.analysis} Usage: /predict [home] vs [away]\\n\\nExample: /predict Liverpool vs Man City`\n      );\n    }\n\n    try {\n      const [home, away] = matchQuery.split(/\\s+vs\\s+/i);\n      if (!home || !away) {\n        return this.telegram.sendMessage(\n          chatId,\n          `Format: /predict Home vs Away\\n\\nExample: /predict Liverpool vs Man City`\n        );\n      }\n\n      const prediction = await this.predictor.predictMatch(home.trim(), away.trim());\n      const confidence = Math.round(prediction.confidence * 100);\n\n      const text =\n        `${ICONS.analysis} <b>Match Prediction</b>\\n\\n` +\n        `${home.trim()} vs ${away.trim()}\\n\\n` +\n        `${prediction.prediction}\\n\\n` +\n        `≡ƒôè Confidence: ${confidence}%\\n` +\n        `${confidence >= 75 ? \"Γ£à High confidence\" : confidence >= 60 ? \"ΓÜá∩╕Å Medium confidence\" : \"ΓÜá∩╕Å Low confidence\"}`;\n\n      await this.analytics.trackPrediction(userId, `${home}-${away}`, prediction.prediction, prediction.confidence);\n      await this.context.recordMessage(userId, `Predicted: ${matchQuery}`, \"system\");\n\n      return this.telegram.sendMessage(chatId, text);\n    } catch (err) {\n      logger.error(\"Predict error\", err);\n      return this.telegram.sendMessage(chatId, \"Prediction service unavailable. Try /live instead.\");\n    }\n  }\n\n  /**\n   * Smart /insights command\n   * Personalized recommendations\n   */\n  async handleInsights(chatId, userId) {\n    try {\n      const user = await this.userService.getUser(userId);\n      const prefs = await this.context.getPreferences(userId);\n      const recommendation = await this.predictor.recommendMatch(userId);\n\n      const aiInsight = await this.gemini.chat(\n        `Generate 3 brief, actionable betting insights for a user interested in ${prefs.favoriteLeagues.join(\", \") || \"football\"}. Keep under 200 chars total.`,\n        {}\n      );\n\n      const text =\n        `≡ƒÆí <b>Personalized Insights</b>\\n\\n` +\n        `Your interests: ${prefs.favoriteLeagues.length ? prefs.favoriteLeagues.join(\", \") : \"all leagues\"}\\n\\n` +\n        `${aiInsight}\\n\\n` +\n        `${recommendation.recommendation}\\n\\n` +\n        `Tip: Set preferences with /settings to get better recommendations.`;\n\n      await this.context.recordMessage(userId, \"Viewed insights\", \"system\");\n\n      return this.telegram.sendMessage(chatId, text);\n    } catch (err) {\n      logger.error(\"Insights error\", err);\n      return this.telegram.sendMessage(chatId, \"Insights unavailable. Try /tips for general advice.\");\n    }\n  }\n\n  /**\n   * Watch match with alerts\n   */\n  async watchMatch(chatId, userId, fixtureId) {\n    try {\n      const subscribed = await this.alerts.subscribeToMatch(userId, fixtureId, {});\n\n      if (subscribed) {\n        return this.telegram.sendMessage(\n          chatId,\n          `≡ƒöö Watching this match! You'll get alerts for goals and important moments.\\n\\nType /unwatch ${fixtureId} to unsubscribe.`\n        );\n      }\n    } catch (err) {\n      logger.error(\"Watch error\", err);\n    }\n  }\n\n  /**\n   * Advanced /compete command\n   * User predictions leaderboard\n   */\n  async handleCompete(chatId, userId) {\n    try {\n      const accuracy = await this.predictor.getPredictionAccuracy(userId);\n      const topPredictors = await this.redis.zrevrange(\"user:accuracy\", 0, 4, \"WITHSCORES\");\n\n      const text =\n        `≡ƒÅå <b>Prediction Leaderboard</b>\\n\\n` +\n        `Your accuracy: ${accuracy}%\\n\\n` +\n        `<b>Top Predictors:</b>\\n`;\n\n      for (let i = 0; i < topPredictors.length; i += 2) {\n        const userIdTop = topPredictors[i];\n        const score = topPredictors[i + 1];\n        const userTop = await this.userService.getUser(userIdTop);\n        text += `${i / 2 + 1}. ${userTop?.name || \"User\"} - ${score}%\\n`;\n      }\n\n      return this.telegram.sendMessage(chatId, text);\n    } catch (err) {\n      logger.error(\"Compete error\", err);\n      return this.telegram.sendMessage(chatId, \"Leaderboard unavailable. Try /stats.\");\n    }\n  }\n\n  /**\n   * Rate limiting check wrapper\n   */\n  async checkRateLimit(chatId, userId, tier = \"default\") {\n    if (await this.rateLimiter.isRateLimited(userId, tier)) {\n      const remaining = await this.rateLimiter.getRemainingRequests(userId, tier);\n      await this.telegram.sendMessage(\n        chatId,\n        `ΓÅ▒∩╕Å Rate limited. You have ${remaining} requests left this minute.`\n      );\n      return false;\n    }\n    return true;\n  }\n}\n\nexport { AdvancedHandler };\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\app.broken.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\app.canonical.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'crypto' is defined but never used.","line":4,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":14},{"ruleId":"no-unused-vars","severity":2,"message":"'path' is defined but never used.","line":7,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":12},{"ruleId":"no-unused-vars","severity":2,"message":"'os' is defined but never used.","line":8,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":10},{"ruleId":"no-unused-vars","severity":2,"message":"'pool' is assigned a value but never used.","line":34,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":34,"endColumn":11},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":44,"column":249,"nodeType":"BlockStatement","messageId":"unexpected","endLine":44,"endColumn":251,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[2108,2108],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Canonical app module for local testing: Express with Redis ping and webhook handler\r\nimport express from 'express';\r\nimport bodyParser from 'body-parser';\r\nimport crypto from 'crypto';\r\nimport { Pool } from 'pg';\r\nimport fs from 'fs';\r\nimport path from 'path';\r\nimport os from 'os';\r\nimport { createClient } from 'redis';\r\n\r\nconst app = express();\r\nconst PORT = Number(process.env.PORT || 5000);\r\n\r\nfunction safeLog(...args) { try { console.log(...args); } catch (e) { /* ignore */ } }\r\n\r\napp.use(bodyParser.json({ limit: '5mb', verify: (req, _res, buf) => { req.rawBody = buf; } }));\r\n\r\nfunction buildPgPoolConfig() {\r\n  const cfg = { connectionString: process.env.DATABASE_URL };\r\n  const mode = String(process.env.PGSSLMODE || '').toLowerCase();\r\n  if (process.env.DATABASE_URL && mode && mode !== 'disable') {\r\n    if (mode === 'verify-ca' || mode === 'verify-full') {\r\n      cfg.ssl = { rejectUnauthorized: true };\r\n      if (process.env.PGSSLROOTCERT) {\r\n        try { cfg.ssl.ca = fs.readFileSync(process.env.PGSSLROOTCERT, 'utf8'); } catch (e) { safeLog('Could not read PGSSLROOTCERT:', e?.message || String(e)); }\r\n      }\r\n    } else {\r\n      cfg.ssl = { rejectUnauthorized: false };\r\n    }\r\n  }\r\n  return cfg;\r\n}\r\n\r\nconst pool = new Pool(buildPgPoolConfig());\r\n\r\nlet redisClient = null;\r\nconst redisUrl = process.env.REDIS_URL || process.env.REDIS_URI || '';\r\nconst redisUsername = process.env.REDIS_USERNAME || process.env.REDIS_USER || undefined;\r\nconst redisPassword = process.env.REDIS_PASSWORD || process.env.REDIS_PWD || undefined;\r\nif (redisUrl) {\r\n  try {\r\n    redisClient = createClient({ url: redisUrl, username: redisUsername || undefined, password: redisPassword || undefined, socket: { tls: String(redisUrl).startsWith('rediss://') } });\r\n    redisClient.on('error', (err) => safeLog('Redis error:', err?.message || String(err)));\r\n    (async () => { try { await redisClient.connect(); const p = await redisClient.ping(); safeLog('Redis connected (PING):', p); } catch (e) { safeLog('Redis connect failed:', e?.message || String(e)); try { await redisClient.disconnect(); } catch {} redisClient = null; } })();\r\n  } catch (e) { safeLog('Failed to create Redis client:', e?.message || String(e)); redisClient = null; }\r\n} else { safeLog('REDIS_URL not set; skipping Redis client initialization'); }\r\napp.locals.redis = redisClient;\r\n\r\napp.get('/health', (_req, res) => res.json({ ok: true }));\r\napp.get('/admin/redis-ping', async (_req, res) => {\r\n  try { const client = app.locals && app.locals.redis; if (!client) return res.status(500).json({ status: 'no redis client' }); const pong = await client.ping(); return res.json({ status: 'ok', pong }); } catch (err) { return res.status(500).json({ status: 'error', message: err?.message || String(err) }); }\r\n});\r\n\r\napp.listen(PORT, () => safeLog(`Canonical app listening on ${PORT}`));\r\n\r\nexport default app;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\app.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\app.legacy.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\app.replaced.js","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token \"'express'\"","line":1,"column":24,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from '\"'\"'express'\"'\"';\nimport bodyParser from '\"'\"'body-parser'\"'\"';\nimport crypto from '\"'\"'crypto'\"'\"';\nimport { Pool } from '\"'\"'pg'\"'\"';\n\n// Minimal replacement app to restore runtime while we repair the original file.\nconst app = express();\nconst PORT = process.env.PORT || 5000;\n\n// DB pool with TLS (Render requires TLS)\nconst pool = new Pool({ connectionString: process.env.DATABASE_URL, ssl: { rejectUnauthorized: false } });\n\n// Middleware: capture raw body for HMAC verification\napp.use(bodyParser.json({ limit: '5mb', verify: (req, _res, buf) => { req.rawBody = buf; } }));\n\nfunction safeLog(...args) { try { console.log(...args); } catch (e) {} }\n\n// Simple admin endpoint for status\napp.get('/admin/queue', (req, res) => {\n  return res.json({ ok: true, commit: process.env.RENDER_GIT_COMMIT || process.env.COMMIT_SHA || null });\n});\n\n// Webhook endpoint for Lipana (M-Pesa) - minimal HMAC check + store\napp.post('/webhook/mpesa', async (req, res) => {\n  const secret = process.env.LIPANA_WEBHOOK_SECRET || process.env.MPESA_WEBHOOK_SECRET || process.env.LIPANA_SECRET;\n  const incoming = req.headers['x-lipana-signature'] || req.headers['x-signature'] || req.headers['signature'] || '';\n  try {\n    const raw = req.rawBody || Buffer.from(JSON.stringify(req.body || {}), 'utf8');\n    let computedHex = null;\n    let computedB64 = null;\n    if (secret) {\n      const h = crypto.createHmac('sha256', String(secret)).update(raw).digest();\n      computedHex = h.toString('hex');\n      computedB64 = h.toString('base64');\n    }\n\n    safeLog('[webhook/mpesa] incomingSig=', incoming, 'computedHexPrefix=', computedHex ? computedHex.slice(0,16) : null);\n\n    // Attempt to persist webhook (best-effort)\n    try {\n      await pool.query(`CREATE TABLE IF NOT EXISTS webhooks (id SERIAL PRIMARY KEY, created_at timestamptz DEFAULT now(), raw_payload jsonb)`);\n      await pool.query('INSERT INTO webhooks(raw_payload) VALUES($1)', [req.body || {}]);\n    } catch (e) {\n      safeLog('DB insert failed (webhook):', e?.message || String(e));\n    }\n\n    // Always return 200 to avoid retries while debugging\n    return res.status(200).send('OK');\n  } catch (err) {\n    safeLog('Webhook handler error:', err?.message || String(err));\n    return res.status(200).send('OK');\n  }\n});\n\napp.listen(PORT, () => safeLog(`Minimal app listening on ${PORT}`));\n\nexport default app;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\app_clean.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'crypto' is defined but never used.","line":4,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":14},{"ruleId":"no-unused-vars","severity":2,"message":"'fs' is defined but never used.","line":5,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":10},{"ruleId":"no-unused-vars","severity":2,"message":"'os' is defined but never used.","line":7,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":10},{"ruleId":"import/no-named-as-default","severity":1,"message":"Using exported name 'DataExposureHandler' as identifier for default import.","line":10,"column":8,"nodeType":"ImportDefaultSpecifier","endLine":10,"endColumn":27},{"ruleId":"no-unused-vars","severity":2,"message":"'__dirname' is assigned a value but never used.","line":16,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":16},{"ruleId":"no-unused-vars","severity":2,"message":"'pool' is assigned a value but never used.","line":19,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":11},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":23,"column":69,"nodeType":"BlockStatement","messageId":"unexpected","endLine":23,"endColumn":71,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[936,936],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Minimal clean Express app used by worker during deploy recovery\r\nimport express from 'express';\r\nimport bodyParser from 'body-parser';\r\nimport crypto from 'crypto';\r\nimport fs from 'fs';\r\nimport path from 'path';\r\nimport os from 'os';\r\nimport { fileURLToPath } from 'url';\r\nimport { Pool } from 'pg';\r\nimport DataExposureHandler from './handlers/data-exposure-handler.js';\r\n\r\nprocess.env.PGSSLMODE = process.env.PGSSLMODE || 'require';\r\nprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = process.env.NODE_TLS_REJECT_UNAUTHORIZED || '0';\r\n\r\nconst __filename = fileURLToPath(import.meta.url);\r\nconst __dirname = path.dirname(__filename);\r\n\r\nconst app = express();\r\nconst pool = new Pool({ connectionString: process.env.DATABASE_URL, ssl: { rejectUnauthorized: false } });\r\n\r\napp.use(bodyParser.json({ limit: '5mb', verify: (req, _res, buf) => { req.rawBody = buf; } }));\r\n\r\nfunction safeLog(...args) { try { console.log(...args); } catch (e) {} }\r\n\r\n// Minimal endpoints (worker only needs registerDataExposureAPI export)\r\napp.get('/health', (_req, res) => res.status(200).json({ ok: true }));\r\n\r\napp.post('/webhook/mpesa', (_req, res) => {\r\n  // worker doesn't handle web traffic; keep a stub to avoid undefined routes\r\n  return res.status(200).send('OK');\r\n});\r\n\r\nexport function registerDataExposureAPI(sportsAggregator) {\r\n  try { new DataExposureHandler(app, sportsAggregator); safeLog('DATA_EXPOSURE: registered'); }\r\n  catch (err) { safeLog('DATA_EXPOSURE registration failed:', String(err)); }\r\n}\r\n\r\nexport default app;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\app_fixed.js","messages":[{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":36,"column":69,"nodeType":"BlockStatement","messageId":"unexpected","endLine":36,"endColumn":71,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[1306,1306],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-undef","severity":2,"message":"'DataExposureHandler' is not defined.","line":114,"column":57,"nodeType":"Identifier","messageId":"undef","endLine":114,"endColumn":76}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Clean canonical app module for webhook capture + fallback\r\nimport express from 'express';\r\nimport bodyParser from 'body-parser';\r\nimport crypto from 'crypto';\r\nimport { Pool } from 'pg';\r\nimport fs from 'fs';\r\nimport path from 'path';\r\nimport os from 'os';\r\n\r\nprocess.env.PGSSLMODE = process.env.PGSSLMODE || 'require';\r\n\r\nconst app = express();\r\n\r\n// Build pool config according to PGSSLMODE\r\nconst poolConfig = { connectionString: process.env.DATABASE_URL };\r\n{\r\n  const pgSslMode = String(process.env.PGSSLMODE || '').toLowerCase();\r\n  if (process.env.DATABASE_URL && pgSslMode && pgSslMode !== 'disable') {\r\n    if (pgSslMode === 'verify-ca' || pgSslMode === 'verify-full') {\r\n      poolConfig.ssl = { rejectUnauthorized: true };\r\n      if (process.env.PGSSLROOTCERT) {\r\n        try { poolConfig.ssl.ca = fs.readFileSync(process.env.PGSSLROOTCERT, 'utf8'); }\r\n        catch (e) { console.warn('Could not read PGSSLROOTCERT:', e?.message || String(e)); }\r\n      }\r\n    } else {\r\n      poolConfig.ssl = { rejectUnauthorized: false };\r\n    }\r\n  }\r\n}\r\n\r\nconst pool = new Pool(poolConfig);\r\n\r\n// capture raw body for HMAC verification\r\napp.use(bodyParser.json({ limit: '5mb', verify: (req, _res, buf) => { req.rawBody = buf; } }));\r\n\r\nfunction safeLog(...args) { try { console.log(...args); } catch (e) {} }\r\n\r\napp.get('/health', (_req, res) => res.status(200).json({ ok: true }));\r\n\r\napp.get('/admin/queue', (_req, res) => {\r\n  return res.json({ ok: true, commit: process.env.RENDER_GIT_COMMIT || process.env.COMMIT_SHA || null });\r\n});\r\n\r\napp.get('/admin/webhook-fallback', (req, res) => {\r\n  try {\r\n    const n = Math.min(100, Number(req.query.n || 50));\r\n    const repoPath = path.join(process.cwd(), 'webhooks.log');\r\n    const tmpPath = path.join(os.tmpdir(), 'webhooks.log');\r\n    const result = {};\r\n\r\n    for (const item of [{ p: repoPath, label: 'repo' }, { p: tmpPath, label: 'tmp' }]) {\r\n      try {\r\n        if (!fs.existsSync(item.p)) { result[item.label] = null; continue; }\r\n        const txt = fs.readFileSync(item.p, 'utf8');\r\n        const lines = txt.split(/\\r?\\n/).filter(Boolean);\r\n        const tail = lines.slice(-n).map(l => {\r\n          try { return JSON.parse(l); } catch { return l; }\r\n        });\r\n        result[item.label] = tail;\r\n      } catch (e) {\r\n        result[item.label] = { error: e?.message || String(e) };\r\n      }\r\n    }\r\n\r\n    return res.json({ ok: true, files: result });\r\n  } catch (err) {\r\n    return res.status(500).json({ ok: false, error: err?.message || String(err) });\r\n  }\r\n});\r\n\r\napp.post('/webhook/mpesa', async (req, res) => {\r\n  const secret = process.env.LIPANA_WEBHOOK_SECRET || process.env.MPESA_WEBHOOK_SECRET || process.env.LIPANA_SECRET;\r\n  const incoming = req.headers['x-lipana-signature'] || req.headers['x-signature'] || req.headers['signature'] || '';\r\n  try {\r\n    const raw = req.rawBody || Buffer.from(JSON.stringify(req.body || {}), 'utf8');\r\n    let computedHex = null;\r\n    let computedB64 = null;\r\n    if (secret) {\r\n      const h = crypto.createHmac('sha256', String(secret)).update(raw).digest();\r\n      computedHex = h.toString('hex');\r\n      computedB64 = h.toString('base64');\r\n    }\r\n\r\n    safeLog('[webhook/mpesa] incoming=', incoming, 'computedHexPrefix=', computedHex ? computedHex.slice(0,16) : null);\r\n\r\n    // Best-effort persistence: try DB, else write fallback files\r\n    try {\r\n      await pool.query(`CREATE TABLE IF NOT EXISTS webhooks (id SERIAL PRIMARY KEY, created_at timestamptz DEFAULT now(), raw_payload jsonb, headers jsonb, incoming_signature text, computed_hex text, computed_b64 text)`);\r\n      await pool.query('INSERT INTO webhooks(raw_payload, headers, incoming_signature, computed_hex, computed_b64) VALUES($1,$2,$3,$4,$5)', [req.body || {}, req.headers || {}, incoming, computedHex, computedB64]);\r\n    } catch (e) {\r\n      try {\r\n        const rec = { ts: new Date().toISOString(), headers: req.headers || {}, body: req.body || {}, incoming_signature: incoming, computedHex, computedB64 };\r\n        const logPath = path.join(process.cwd(), 'webhooks.log');\r\n        const tmpPath = path.join(os.tmpdir(), 'webhooks.log');\r\n        fs.appendFileSync(logPath, JSON.stringify(rec) + '\\n', { encoding: 'utf8' });\r\n        fs.appendFileSync(tmpPath, JSON.stringify(rec) + '\\n', { encoding: 'utf8' });\r\n        safeLog('DB insert failed; appended webhook to', logPath, 'and', tmpPath);\r\n      } catch (fsErr) {\r\n        safeLog('DB insert failed and fallback file write failed:', fsErr?.message || String(fsErr));\r\n      }\r\n      safeLog('DB insert failed (webhook):', e?.message || String(e));\r\n    }\r\n\r\n    // Return 200 so upstream won't retry while we debug\r\n    return res.status(200).send('OK');\r\n  } catch (err) {\r\n    safeLog('Webhook handler error:', err?.message || String(err));\r\n    return res.status(200).send('OK');\r\n  }\r\n});\r\n\r\nexport function registerDataExposureAPI(sportsAggregator) {\r\n  try {\r\n    if (typeof DataExposureHandler !== 'undefined') new DataExposureHandler(app, sportsAggregator);\r\n    safeLog('DATA_EXPOSURE: registered endpoints');\r\n  } catch (err) { safeLog('DATA_EXPOSURE registration failed:', String(err)); }\r\n}\r\n\r\nexport default app;\r\n\r\n// Start server only when executed directly (node src/app.js)\r\nconst PORT = process.env.PORT || 5000;\r\ntry {\r\n  const invokedScript = process.argv[1] ? path.resolve(process.argv[1]) : null;\r\n  const appScript = path.resolve('src', 'app.js');\r\n  if (invokedScript && invokedScript === appScript) {\r\n    app.listen(PORT, () => safeLog(`Server running on port ${PORT}`));\r\n  }\r\n} catch (e) { /* non-fatal */ }\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\boot.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\bot\\callbacks.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\bot\\command-router.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\bot\\db.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\bot\\football.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\bot\\handlers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\bot\\handlers\\analysis.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'axios' is defined but never used.","line":1,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":13},{"ruleId":"import/no-named-as-default","severity":1,"message":"Using exported name 'SportsAggregator' as identifier for default import.","line":2,"column":8,"nodeType":"ImportDefaultSpecifier","endLine":2,"endColumn":24},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":103,"column":72,"nodeType":"BlockStatement","messageId":"unexpected","endLine":103,"endColumn":74,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[4796,4796],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios from 'axios';\r\nimport SportsAggregator from '../../services/sports-aggregator.js';\r\n\r\nexport async function analyse_match(ctx, matchId) {\r\n  try {\r\n    const agg = new SportsAggregator();\r\n\r\n    // Step 1: get live matches from Football-Data (normalized)\r\n    const liveMatches = await agg._getLiveFromFootballData();\r\n    const match = (liveMatches || []).find(m => String(m.id) === String(matchId));\r\n\r\n    if (!match) {\r\n      await ctx.editMessageText('ΓÜá∩╕Å Match not found or not live.');\r\n      return;\r\n    }\r\n\r\n    // Derive team identifiers for SportMonks where possible\r\n    const homeId = match.raw && (match.raw.homeTeam && (match.raw.homeTeam.id || match.raw.homeTeam.name)) || match.home;\r\n    const awayId = match.raw && (match.raw.awayTeam && (match.raw.awayTeam.id || match.raw.awayTeam.name)) || match.away;\r\n\r\n    // Step 2: Head-to-head (SportMonks)\r\n    let h2h = [];\r\n    try {\r\n      h2h = await agg.getHeadToHead(homeId, awayId);\r\n    } catch (e) {\r\n      console.warn('Head-to-head fetch failed:', e?.message || e);\r\n    }\r\n\r\n    // Step 3: Recent form (SportMonks)\r\n    let recentFormHome = [];\r\n    let recentFormAway = [];\r\n    try {\r\n      recentFormHome = await agg.getRecentForm(homeId, 5);\r\n      recentFormAway = await agg.getRecentForm(awayId, 5);\r\n    } catch (e) {\r\n      console.warn('Recent form fetch failed:', e?.message || e);\r\n    }\r\n\r\n    // Step 4: Standings (Football-Data) - try to infer competition code\r\n    let standings = [];\r\n    try {\r\n      const comp = match.raw && (match.raw.competition && (match.raw.competition.id || match.raw.competition.code)) || match.competition || null;\r\n      if (comp) standings = await agg.getStandings(comp);\r\n    } catch (e) {\r\n      console.warn('Standings fetch failed:', e?.message || e);\r\n    }\r\n\r\n    // Step 5: Odds (SportMonks)\r\n    let odds = [];\r\n    try {\r\n      odds = await agg.getOdds(match.id);\r\n    } catch (e) {\r\n      console.warn('Odds fetch failed:', e?.message || e);\r\n    }\r\n\r\n    // Format analysis text\r\n    let analysisText = `*Match Analysis: ${match.home} vs ${match.away}*\\n\\n`;\r\n    analysisText += `Status: ${match.status}\\n`;\r\n    analysisText += `Score: ${match.homeScore ?? '-'}-${match.awayScore ?? '-'}\\n`;\r\n    analysisText += `Competition: ${match.competition || (match.raw && match.raw.competition && match.raw.competition.name) || 'Unknown'}\\n`;\r\n    analysisText += `Kickoff: ${match.time || match.kickoff || 'TBA'}\\n`;\r\n    analysisText += `Venue: ${match.venue || 'TBA'}\\n`;\r\n    analysisText += `Provider: Football-Data.org\\n\\n`;\r\n\r\n    if (h2h && h2h.totalMatches !== undefined) {\r\n      analysisText += `*Head-to-Head:*\r\nTotal: ${h2h.totalMatches} | Home wins: ${h2h.homeWins} | Away wins: ${h2h.awayWins} | Draws: ${h2h.draws}\\n\\n`;\r\n    }\r\n\r\n    if (recentFormHome && recentFormHome.length > 0) {\r\n      analysisText += `*Recent Form (${match.home}):*\\n`;\r\n      analysisText += recentFormHome.slice(0,5).map(m => `${m.starting_at || m.date || m.date_time || m.utcDate || ''}: ${m.result || (m.score ? JSON.stringify(m.score) : '')}`).join('\\n') + '\\n\\n';\r\n    }\r\n\r\n    if (recentFormAway && recentFormAway.length > 0) {\r\n      analysisText += `*Recent Form (${match.away}):*\\n`;\r\n      analysisText += recentFormAway.slice(0,5).map(m => `${m.starting_at || m.date || m.date_time || m.utcDate || ''}: ${m.result || (m.score ? JSON.stringify(m.score) : '')}`).join('\\n') + '\\n\\n';\r\n    }\r\n\r\n    if (standings && standings.length > 0) {\r\n      const homeStanding = standings.find(t => t.team && (t.team.name === match.home || t.team.id === match.homeId || t.team.id === match.raw?.homeTeam?.id));\r\n      const awayStanding = standings.find(t => t.team && (t.team.name === match.away || t.team.id === match.awayId || t.team.id === match.raw?.awayTeam?.id));\r\n      if (homeStanding || awayStanding) {\r\n        analysisText += `*League Standings:*\\n`;\r\n        if (homeStanding) analysisText += `${match.home}: ${homeStanding.position} (${homeStanding.points} pts)\\n`;\r\n        if (awayStanding) analysisText += `${match.away}: ${awayStanding.position} (${awayStanding.points} pts)\\n`;\r\n        analysisText += '\\n';\r\n      }\r\n    }\r\n\r\n    if (odds && odds.length > 0) {\r\n      analysisText += `*Odds (sample):*\\n`;\r\n      const o = odds[0];\r\n      if (o && o.bookmakers) {\r\n        const markets = o.bookmakers[0] && o.bookmakers[0].markets ? o.bookmakers[0].markets : [];\r\n        analysisText += markets.slice(0,1).map(m => `${m.key}: ${JSON.stringify(m.selections || m.outcomes || m.odds)}`).join('\\n') + '\\n\\n';\r\n      }\r\n    }\r\n\r\n    await ctx.editMessageText(analysisText, { parse_mode: 'Markdown' });\r\n  } catch (err) {\r\n    console.error('analyse_match handler failed', err);\r\n    try { await ctx.editMessageText('ΓÜá∩╕Å Analysis failed.'); } catch(_) {}\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\bot\\mpesa.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'crypto' is defined but never used.","line":1,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":14}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import crypto from 'crypto';\r\n\r\n// Minimal Safaricom Daraja (M-Pesa) client for STK push using till/shortcode.\r\n// Configuration is supplied via environment variables at runtime only.\r\n\r\nconst DEFAULTS = {\r\n  env: process.env.MPESA_ENV || 'sandbox',\r\n  consumerKey: process.env.MPESA_CONSUMER_KEY || null,\r\n  consumerSecret: process.env.MPESA_CONSUMER_SECRET || null,\r\n  shortcode: process.env.MPESA_SHORTCODE || null,\r\n  passkey: process.env.MPESA_PASSKEY || null,\r\n  callbackUrl: process.env.MPESA_CALLBACK_URL || null\r\n};\r\n\r\nfunction baseUrlFor(env) {\r\n  if (env === 'production') return 'https://api.safaricom.co.ke';\r\n  return 'https://sandbox.safaricom.co.ke';\r\n}\r\n\r\nfunction timestamp() {\r\n  const d = new Date();\r\n  const pad = (n) => String(n).padStart(2, '0');\r\n  const yyyy = d.getFullYear();\r\n  const MM = pad(d.getMonth() + 1);\r\n  const dd = pad(d.getDate());\r\n  const hh = pad(d.getHours());\r\n  const mm = pad(d.getMinutes());\r\n  const ss = pad(d.getSeconds());\r\n  return `${yyyy}${MM}${dd}${hh}${mm}${ss}`;\r\n}\r\n\r\nasync function getAccessToken({ consumerKey, consumerSecret, env = 'sandbox' } = {}) {\r\n  const key = consumerKey || DEFAULTS.consumerKey;\r\n  const secret = consumerSecret || DEFAULTS.consumerSecret;\r\n  if (!key || !secret) throw new Error('Missing MPESA consumer key/secret in environment');\r\n  const url = baseUrlFor(env) + '/oauth/v1/generate?grant_type=client_credentials';\r\n  const auth = Buffer.from(`${key}:${secret}`).toString('base64');\r\n  const res = await fetch(url, { headers: { Authorization: `Basic ${auth}` } });\r\n  if (!res.ok) {\r\n    const txt = await res.text();\r\n    throw new Error(`Failed to get access token: ${res.status} ${txt}`);\r\n  }\r\n  const body = await res.json();\r\n  return body.access_token;\r\n}\r\n\r\nfunction buildPassword(shortcode, passkey, ts) {\r\n  const raw = `${shortcode}${passkey}${ts}`;\r\n  return Buffer.from(raw).toString('base64');\r\n}\r\n\r\nexport async function stkPush({ amount = 300, phone, accountReference = 'Betrix', transactionDesc = 'Betrix access', env = DEFAULTS.env, consumerKey, consumerSecret, shortcode = DEFAULTS.shortcode, passkey = DEFAULTS.passkey, callbackUrl = DEFAULTS.callbackUrl } = {}) {\r\n  if (!phone) throw new Error('Phone number is required for STK push');\r\n  if (!shortcode || !passkey) throw new Error('MPESA_SHORTCODE and MPESA_PASSKEY must be set in environment');\r\n  const token = await getAccessToken({ consumerKey, consumerSecret, env });\r\n  const ts = timestamp();\r\n  const password = buildPassword(shortcode, passkey, ts);\r\n  const url = baseUrlFor(env) + '/mpesa/stkpush/v1/processrequest';\r\n  const body = {\r\n    BusinessShortCode: shortcode,\r\n    Password: password,\r\n    Timestamp: ts,\r\n    TransactionType: 'CustomerPayBillOnline',\r\n    Amount: amount,\r\n    PartyA: phone,\r\n    PartyB: shortcode,\r\n    PhoneNumber: phone,\r\n    CallBackURL: callbackUrl,\r\n    AccountReference: accountReference,\r\n    TransactionDesc: transactionDesc\r\n  };\r\n  const res = await fetch(url, { method: 'POST', headers: { Authorization: `Bearer ${token}`, 'Content-Type': 'application/json' }, body: JSON.stringify(body) });\r\n  const json = await res.json().catch(() => null);\r\n  if (!res.ok) {\r\n    throw new Error(`STK push failed: ${res.status} ${JSON.stringify(json)}`);\r\n  }\r\n  // Typical successful response: { MerchantRequestID, CheckoutRequestID, ResponseCode: '0', ResponseDescription }\r\n  return { raw: json };\r\n}\r\n\r\nexport default { stkPush };\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\bot\\payments.js","messages":[{"ruleId":"import/no-named-as-default-member","severity":1,"message":"Caution: `mpesa` also has a named export `stkPush`. Check if you meant to write `import {stkPush} from './mpesa.js'` instead.","line":42,"column":26,"nodeType":"MemberExpression","endLine":42,"endColumn":39}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createPayment, updatePaymentStatus } from './db.js';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport mpesa from './mpesa.js';\r\nimport lipana from '../lib/lipana-client.js';\r\n\r\n// Local M-Pesa STK push helper (stubbed). Creates a pending payment record\r\n// and returns a tx_ref. Real provider integration should replace this.\r\nexport async function initiateStkPush({ user_id, msisdn, amount = 300 }) {\r\n  const tx_ref = `betrix_${Date.now()}_${Math.floor(Math.random() * 1000)}`;\r\n  const payment = {\r\n    id: uuidv4(),\r\n    user_id,\r\n    amount,\r\n    currency: 'KES',\r\n    method: 'mpesa_stk',\r\n    tx_ref,\r\n    status: 'pending',\r\n    metadata: { msisdn }\r\n  };\r\n  await createPayment(payment);\r\n\r\n  // If Lipana creds are configured, attempt Lipana STK push\r\n  if (process.env.LIPANA_SECRET || process.env.LIPANA_API_KEY) {\r\n    try {\r\n      const callback = process.env.LIPANA_CALLBACK_URL || process.env.MPESA_CALLBACK_URL || process.env.MPESA_CALLBACK_URL;\r\n      const resp = await lipana.stkPush({ amount, phone: msisdn, tx_ref, reference: tx_ref, callback_url: callback });\r\n      // Lipana returns created transaction data under resp.raw.data.transactionId (or resp.raw.data._id)\r\n      const checkout = resp?.raw?.data?.transactionId || resp?.raw?.data?._id || null;\r\n      if (checkout && resp.status >= 200 && resp.status < 300) {\r\n        await updatePaymentStatus(tx_ref, 'initiated', checkout, { provider_checkout_id: checkout, lipana_response: resp.raw });\r\n      }\r\n      return { tx_ref, provider_response: resp.raw, statusCode: resp.status };\r\n    } catch (err) {\r\n      console.error('Lipana STK push error', err);\r\n      return { tx_ref, error: String(err.message || err) };\r\n    }\r\n  }\r\n\r\n  // If MPESA env is configured, attempt a real STK push.\r\n  if (process.env.MPESA_CONSUMER_KEY && process.env.MPESA_CONSUMER_SECRET) {\r\n    try {\r\n      const resp = await mpesa.stkPush({ amount, phone: msisdn });\r\n      // record provider checkout id if present\r\n      const checkout = resp?.raw?.CheckoutRequestID || resp?.raw?.MerchantRequestID || null;\r\n      if (checkout) {\r\n        await updatePaymentStatus(tx_ref, 'initiated', checkout, { provider_checkout_id: checkout, mpesa_response: resp.raw });\r\n      }\r\n      return { tx_ref, provider_response: resp.raw };\r\n    } catch (err) {\r\n      console.error('MPESA STK push error', err);\r\n      // leave payment as pending and return error message\r\n      return { tx_ref, error: String(err.message || err) };\r\n    }\r\n  }\r\n\r\n  // Fallback stub behavior\r\n  return { tx_ref, provider_response: { message: 'stubbed STK push queued' } };\r\n}\r\n\r\n// Handle an incoming M-Pesa webhook / callback. This will update payment\r\n// status by tx_ref and return the updated payment row.\r\nexport async function handleMpesaCallback({ tx_ref, status, provider_tx_id = null, metadata = {} }) {\r\n  // Normalize status to expected values\r\n  const normalized = (status === 'SUCCESS' || status === 'success' || status === 'OK') ? 'success' : (status === 'FAILED' || status === 'failed') ? 'failed' : 'pending';\r\n  try {\r\n    const updated = await updatePaymentStatus(tx_ref, normalized, provider_tx_id, metadata);\r\n    return updated;\r\n  } catch (err) {\r\n    // If DB is not reachable or payment not found, return a best-effort simulated result\r\n    console.warn('handleMpesaCallback fallback - DB update failed or payment not found', String(err.message || err));\r\n    return {\r\n      tx_ref,\r\n      status: normalized,\r\n      tx_id: provider_tx_id,\r\n      metadata,\r\n      note: 'simulated - DB update not performed'\r\n    };\r\n  }\r\n}\r\n\r\nexport async function verifyPayment(tx_ref) {\r\n  // For now simply return DB state; real implementation would call provider\r\n  // or rely on webhook verification.\r\n  // We'll keep this placeholder to avoid breaking callers.\r\n  return { tx_ref };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\bot\\server.js","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token }","line":137,"column":3,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import 'dotenv/config';\r\nimport { Telegraf, Scenes, session, Markup } from 'telegraf';\r\nimport express from 'express';\r\nimport bodyParser from 'body-parser';\r\nimport { Pool } from 'pg';\r\nimport { upsertUser, createPayment, getUserById, getRecentPayments, getPaymentByProviderCheckout, getPaymentByTxRef, updatePaymentStatus } from './db.js';\r\nimport { initiateStkPush, handleMpesaCallback } from './payments.js';\r\nimport football, { setAggregator } from './football.js';\r\nimport { getRedis } from '../../src/lib/redis-factory.js';\r\nimport { SportsAggregator } from '../../src/services/sports-aggregator.js';\r\n\r\n// Initialize a SportsAggregator instance (shared Redis)\r\nconst redisClient = getRedis();\r\nconst sportsAgg = new SportsAggregator(redisClient);\r\nsetAggregator(sportsAgg);\r\n\r\nconst BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;\r\nif (!BOT_TOKEN) {\r\n  console.error('Missing TELEGRAM_BOT_TOKEN in environment');\r\n  process.exit(1);\r\n}\r\n\r\nconst bot = new Telegraf(BOT_TOKEN);\r\n\r\n// --- Admin /health command guard ---\r\nconst ADMIN_USER_ID = process.env.ADMIN_TELEGRAM_ID ? String(process.env.ADMIN_TELEGRAM_ID) : null;\r\n\r\n// Simple session middleware (keeps minimal signup state)\r\nbot.use(session());\r\n\r\nfunction mainKeyboard() {\r\n  return Markup.inlineKeyboard([\r\n    [Markup.button.callback('ΓÜ╜ Football', 'sport:football')],\r\n    [Markup.button.callback('≡ƒöÉ Sign up / Profile', 'signup:start')],\r\n    [Markup.button.callback('≡ƒÆ│ Pay 300 KES', 'pay:start')]\r\n  ]);\r\n}\r\n\r\nfunction payKeyboard() {\r\n  return Markup.inlineKeyboard([\r\n    [Markup.button.callback('M-Pesa (Lipana)', 'pay:method:lipana'), Markup.button.callback('M-Pesa (Daraja)', 'pay:method:mpesa')]\r\n  ]);\r\n}\r\n\r\nasync function pollPaymentStatusAndNotify(ctx, tx_ref, timeoutSeconds = 180) {\r\n  const interval = 3000; // 3s\r\n  const maxAttempts = Math.ceil(timeoutSeconds * 1000 / interval);\r\n  for (let i = 0; i < maxAttempts; i++) {\r\n    try {\r\n      const p = await getPaymentByTxRef(tx_ref);\r\n      const status = p?.status;\r\n      if (status && (status === 'success' || status === 'failed')) {\r\n        if (status === 'success') {\r\n          await ctx.reply('Payment confirmed ΓÇö thank you! Your account is now active.');\r\n          try { await upsertUser({ user_id: ctx.from.id, status: 'active' }); } catch (e) { /* ignore */ }\r\n        } else {\r\n          await ctx.reply('Payment failed or was cancelled. Please try again.');\r\n        }\r\n        return p;\r\n      }\r\n    } catch (err) {\r\n      console.error('Error polling payment status', err);\r\n    }\r\n    await new Promise(r => setTimeout(r, interval));\r\n  }\r\n  await ctx.reply('No confirmation received yet. We will notify you when the payment completes.');\r\n  return null;\r\n}\r\n\r\nbot.action('pay:start', async (ctx) => {\r\n  await ctx.answerCbQuery();\r\n  await ctx.reply('Choose payment method:', payKeyboard());\r\n});\r\n\r\nbot.action('pay:method:lipana', async (ctx) => {\r\n  await ctx.answerCbQuery();\r\n  ctx.session.paymentMethod = 'lipana';\r\n  await ctx.reply('You chose Lipana M-Pesa. We will use M-Pesa STK to collect 300 KES.');\r\n  // trigger payment flow\r\n  const fakeCtx = ctx; // reuse same ctx\r\n  await (async function trigger() {\r\n    const userId = ctx.from.id;\r\n    let msisdn = ctx.session?.msisdn || null;\r\n    if (!msisdn) {\r\n      try { const u = await getUserById(userId); if (u && u.msisdn) msisdn = u.msisdn; } catch (e) { /* ignore */ }\r\n    }\r\n    if (!msisdn) {\r\n      await ctx.reply('Please send your phone number first (e.g. 2547XXXXXXXX)');\r\n      ctx.session.payAfterNumber = true;\r\n      return;\r\n    }\r\n    await ctx.reply('Initiating STK push ΓÇö please complete the prompt on your phone. I will wait for confirmation...');\r\n    try {\r\n      const { tx_ref } = await initiateStkPush({ user_id: userId, msisdn, amount: 300 });\r\n      ctx.session.lastPayment = { tx_ref, amount: 300 };\r\n      await ctx.reply(`STK Push initiated. Reference: ${tx_ref}. Please complete the prompt on your phone.`, Markup.inlineKeyboard([\r\n        [Markup.button.callback('Γ¥î Cancel payment', 'pay:cancel')],\r\n        [Markup.button.callback('≡ƒöü Retry payment', 'pay:retry')]\r\n      ]));\r\n      await pollPaymentStatusAndNotify(ctx, tx_ref, 180);\r\n    } catch (err) {\r\n      console.error('STK push error', err);\r\n      await ctx.reply('Failed to initiate payment. Please try again later.');\r\n    }\r\n  })();\r\n});\r\n\r\nbot.action('pay:method:mpesa', async (ctx) => {\r\n  await ctx.answerCbQuery();\r\n  ctx.session.paymentMethod = 'mpesa';\r\n  await ctx.reply('You chose Daraja M-Pesa. We will use M-Pesa STK to collect 300 KES.');\r\n  // same trigger logic as lipana\r\n  const userId = ctx.from.id;\r\n  let msisdn = ctx.session?.msisdn || null;\r\n  if (!msisdn) {\r\n    try { const u = await getUserById(userId); if (u && u.msisdn) msisdn = u.msisdn; } catch (e) { /* ignore */ }\r\n  }\r\n  if (!msisdn) {\r\n    await ctx.reply('Please send your phone number first (e.g. 2547XXXXXXXX)');\r\n    ctx.session.payAfterNumber = true;\r\n    return;\r\n  }\r\n  await ctx.reply('Initiating STK push ΓÇö please complete the prompt on your phone. I will wait for confirmation...');\r\n  try {\r\n    const { tx_ref } = await initiateStkPush({ user_id: userId, msisdn, amount: 300 });\r\n    ctx.session.lastPayment = { tx_ref, amount: 300 };\r\n    await ctx.reply(`STK Push initiated. Reference: ${tx_ref}. Please complete the prompt on your phone.`, Markup.inlineKeyboard([\r\n      [Markup.button.callback('Γ¥î Cancel payment', 'pay:cancel')],\r\n      [Markup.button.callback('≡ƒöü Retry payment', 'pay:retry')]\r\n    ]));\r\n    await pollPaymentStatusAndNotify(ctx, tx_ref, 180);\r\n  } catch (err) {\r\n    console.error('STK push error', err);\r\n    await ctx.reply('Failed to initiate payment. Please try again later.');\r\n  }\r\n});\r\n  }\r\n  const lines = [ `ΓÜ╜ BETRIX ΓÇó Upcoming Fixtures (showing ${items.length} of ${total})` ];\r\n  const kb = [];\r\n  for (const m of items) {\r\n    lines.push('ΓÇó ' + football.formatMatchShort(m));\r\n    const id = m.id ?? m.match_id ?? m.fixture?.id ?? m.home?.id + ':' + m.away?.id;\r\n    kb.push([Markup.button.callback('Details', `match:${id}:football`)]);\r\n  }\r\n  kb.push([Markup.button.callback('≡ƒöÖ Back', 'sport:football')]);\r\n  await ctx.editMessageText(lines.join('\\n'), { reply_markup: Markup.inlineKeyboard(kb).reply_markup });\r\n});\r\n\r\n// Match details handler (best-effort id lookup)\r\nbot.action(/match:(.+):football/, async (ctx) => {\r\n  await ctx.answerCbQuery();\r\n  const matchId = ctx.match[1];\r\n  const all = await football.loadMatches();\r\n  const found = all.find(m => String(m.id) === String(matchId) || String(m.match_id) === String(matchId) || String(m.fixture?.id) === String(matchId) || (`${m.home?.id || ''}:${m.away?.id || ''}`) === String(matchId));\r\n  if (!found) {\r\n    await ctx.editMessageText(`Match not found. Showing list instead.`, { reply_markup: Markup.inlineKeyboard([[Markup.button.callback('≡ƒöÖ Back', 'sport:football')]]).reply_markup });\r\n    return;\r\n  }\r\n  const detail = football.formatMatchDetail(found);\r\n  await ctx.editMessageText(detail, { reply_markup: Markup.inlineKeyboard([[Markup.button.callback('≡ƒöÖ Back', 'sport:football')]]).reply_markup });\r\n});\r\n\r\nbot.on('text', async (ctx, next) => {\r\n  const s = ctx.session.signup;\r\n  if (!s) return next();\r\n\r\n  const text = ctx.message.text.trim();\r\n  if (s.step === 1) {\r\n    s.full_name = text;\r\n    s.step = 2;\r\n    await ctx.reply('Thanks. What is your phone number (e.g. 2547XXXXXXXX)?');\r\n    return;\r\n  }\r\n  if (s.step === 2) {\r\n    s.msisdn = text;\r\n    s.step = 3;\r\n    await ctx.reply('Optional: What country are you in? (or send \"skip\")');\r\n    return;\r\n  }\r\n  if (s.step === 3) {\r\n    s.country = text.toLowerCase() === 'skip' ? null : text;\r\n    // persist user\r\n    const user = {\r\n      user_id: ctx.from.id,\r\n      full_name: s.full_name,\r\n      msisdn: s.msisdn,\r\n      country: s.country,\r\n      status: 'trial'\r\n    };\r\n    try {\r\n      await upsertUser(user);\r\n      await ctx.reply('Profile saved! You can now pay to unlock full access.', payKeyboard());\r\n    } catch (err) {\r\n      console.error('Error saving user', err);\r\n      await ctx.reply('Sorry, something went wrong saving your profile. Try again later.');\r\n    }\r\n    ctx.session.signup = null;\r\n    return;\r\n  }\r\n  return next();\r\n});\r\n\r\n// Payment action - initiate STK push\r\nbot.action('pay:stk', async (ctx) => {\r\n  await ctx.answerCbQuery();\r\n  // load user data (in real app, query DB)\r\n  const userId = ctx.from.id;\r\n  // For the minimal scaffold, read msisdn from session or prompt\r\n  const msisdn = ctx.session?.msisdn || null;\r\n  // Try DB if not in session\r\n  if (!msisdn) {\r\n    try {\r\n      const u = await getUserById(userId);\r\n      if (u && u.msisdn) ctx.session.msisdn = u.msisdn;\r\n    } catch (err) {\r\n      console.error('Error reading user for msisdn fallback', err);\r\n    }\r\n  }\r\n  if (!ctx.session?.msisdn) {\r\n    await ctx.reply('Please send your phone number first (e.g. 2547XXXXXXXX)');\r\n    ctx.session.payAfterNumber = true;\r\n    return;\r\n  }\r\n\r\n  try {\r\n    const { tx_ref } = await initiateStkPush({ user_id: userId, msisdn, amount: 300 });\r\n    ctx.session.lastPayment = { tx_ref, amount: 300 };\r\n    await ctx.reply(`STK Push initiated. Reference: ${tx_ref}. Complete the prompt on your phone.`, Markup.inlineKeyboard([\r\n      [Markup.button.callback('Γ¥î Cancel payment', 'pay:cancel')],\r\n      [Markup.button.callback('≡ƒöü Retry payment', 'pay:retry')]\r\n    ]));\r\n  } catch (err) {\r\n    console.error('STK push error', err);\r\n    await ctx.reply('Failed to initiate payment. Please try again later.');\r\n  }\r\n});\r\n\r\n// If user previously indicated they will pay after giving number\r\nbot.hears(/^[0-9]{9,12}$/, async (ctx) => {\r\n  const possible = ctx.message.text.trim();\r\n  if (ctx.session?.payAfterNumber) {\r\n    ctx.session.payAfterNumber = false;\r\n    ctx.session.msisdn = possible;\r\n    // auto-trigger payment according to chosen method (default lipana)\r\n    await ctx.reply('Thanks ΓÇö initiating payment...');\r\n    try {\r\n      const { tx_ref } = await initiateStkPush({ user_id: ctx.from.id, msisdn: possible, amount: 300 });\r\n      ctx.session.lastPayment = { tx_ref, amount: 300 };\r\n      await ctx.reply(`STK Push initiated. Reference: ${tx_ref}. Check your phone.`, Markup.inlineKeyboard([\r\n        [Markup.button.callback('Γ¥î Cancel payment', 'pay:cancel')],\r\n        [Markup.button.callback('≡ƒöü Retry payment', 'pay:retry')]\r\n      ]));\r\n      // poll and notify\r\n      await pollPaymentStatusAndNotify(ctx, tx_ref, 180);\r\n    } catch (err) {\r\n      console.error(err);\r\n      await ctx.reply('Could not start payment. Please try again later.');\r\n    }\r\n    return;\r\n  }\r\n});\r\n\r\n// Allow users to cancel or retry while waiting for STK\r\nbot.action('pay:cancel', async (ctx) => {\r\n  await ctx.answerCbQuery();\r\n  const last = ctx.session?.lastPayment;\r\n  if (!last || !last.tx_ref) {\r\n    await ctx.reply('No pending payment found to cancel.');\r\n    return;\r\n  }\r\n  try {\r\n    await updatePaymentStatus(last.tx_ref, 'failed', null, { cancelled_by: ctx.from.id });\r\n    ctx.session.lastPayment = null;\r\n    await ctx.reply('Payment cancelled. If you were charged, contact support.');\r\n  } catch (err) {\r\n    console.error('Failed to cancel payment', err);\r\n    await ctx.reply('Could not cancel the payment. Please try again or contact support.');\r\n  }\r\n});\r\n\r\nbot.action('pay:retry', async (ctx) => {\r\n  await ctx.answerCbQuery();\r\n  const last = ctx.session?.lastPayment;\r\n  if (!last || !last.tx_ref) {\r\n    await ctx.reply('No recent payment to retry.');\r\n    return;\r\n  }\r\n  let msisdn = ctx.session?.msisdn || null;\r\n  if (!msisdn) {\r\n    try { const u = await getUserById(ctx.from.id); if (u && u.msisdn) msisdn = u.msisdn; } catch (e) { /* ignore */ }\r\n  }\r\n  if (!msisdn) {\r\n    await ctx.reply('No phone number found. Please send your phone number (e.g. 2547XXXXXXXX) to retry.');\r\n    ctx.session.payAfterNumber = true;\r\n    return;\r\n  }\r\n  try {\r\n    const { tx_ref } = await initiateStkPush({ user_id: ctx.from.id, msisdn, amount: last.amount || 300 });\r\n    ctx.session.lastPayment = { tx_ref, amount: last.amount || 300 };\r\n    await ctx.reply(`Retry initiated. Reference: ${tx_ref}. Please complete the prompt on your phone.`, Markup.inlineKeyboard([\r\n      [Markup.button.callback('Γ¥î Cancel payment', 'pay:cancel')],\r\n      [Markup.button.callback('≡ƒöü Retry payment', 'pay:retry')]\r\n    ]));\r\n    await pollPaymentStatusAndNotify(ctx, tx_ref, 180);\r\n  } catch (err) {\r\n    console.error('Retry STK error', err);\r\n    await ctx.reply('Retry failed. Please try again later.');\r\n  }\r\n});\r\n\r\n// Simple middleware to enforce active status for commands (example)\r\nbot.use(async (ctx, next) => {\r\n  // allow /start and admin health\r\n  if (ctx.updateType === 'message' && ctx.message && ctx.message.text) {\r\n    const t = ctx.message.text.trim();\r\n    if (t.startsWith('/start')) return next();\r\n    if (t.startsWith('/health')) return next();\r\n  }\r\n\r\n  // For callback queries and other commands, check DB for user status\r\n  const userId = ctx.from && ctx.from.id;\r\n  if (!userId) return next();\r\n  try {\r\n    const user = await getUserById(userId);\r\n    if (user && user.status && user.status !== 'active') {\r\n      // If user is not active, prompt payment flow\r\n      await ctx.reply('Your account is not active. Please pay 300 KES to unlock full access.', payKeyboard());\r\n      return; // short-circuit\r\n    }\r\n  } catch (err) {\r\n    console.error('Error checking user status', err);\r\n  }\r\n  return next();\r\n});\r\n\r\n// Admin health command (restricted by ADMIN_TELEGRAM_ID env var)\r\nbot.command('health', async (ctx) => {\r\n  if (!ADMIN_USER_ID || String(ctx.from.id) !== ADMIN_USER_ID) {\r\n    await ctx.reply('Unauthorized');\r\n    return;\r\n  }\r\n  // Check Redis and SportsAggregator health\r\n  try {\r\n    const r = await redisClient.ping();\r\n    const live = await sportsAgg.getAllLiveMatches();\r\n    const fixtures = await sportsAgg.getFixtures();\r\n    await ctx.reply(`Health OK\\nRedis: ${r}\\nLive matches: ${live?.length || 0}\\nFixtures cached: ${fixtures?.length || 0}`);\r\n  } catch (err) {\r\n    await ctx.reply('Health check failed: ' + String(err.message || err));\r\n  }\r\n});\r\n\r\n// Admin command to list recent payments\r\nbot.command('payments', async (ctx) => {\r\n  if (!ADMIN_USER_ID || String(ctx.from.id) !== ADMIN_USER_ID) {\r\n    await ctx.reply('Unauthorized');\r\n    return;\r\n  }\r\n  try {\r\n    const items = await getRecentPayments(12);\r\n    if (!items || items.length === 0) {\r\n      await ctx.reply('No payments found.');\r\n      return;\r\n    }\r\n    const lines = items.map(p => {\r\n      const when = p.created_at ? new Date(p.created_at).toISOString().replace('T', ' ').replace('Z','') : '';\r\n      const phone = p.phone_number || (p.metadata && p.metadata.msisdn) || '';\r\n      return `ΓÇó ${p.tx_ref || p.id} ΓÇö ${p.status} ΓÇö ${p.amount} ${p.currency || ''} ΓÇö ${phone} ΓÇö ${when}`;\r\n    });\r\n    // Send in chunks if too long\r\n    const chunkSize = 10;\r\n    for (let i = 0; i < lines.length; i += chunkSize) {\r\n      await ctx.reply('\\n' + lines.slice(i, i + chunkSize).join('\\n'));\r\n    }\r\n  } catch (err) {\r\n    console.error('Failed to list payments', err);\r\n    await ctx.reply('Failed to fetch payments: ' + String(err.message || err));\r\n  }\r\n});\r\n\r\n// --- Small express server to receive provider webhooks (M-Pesa callback) ---\r\nconst app = express();\r\napp.use(bodyParser.json());\r\n\r\napp.post('/webhook/mpesa', async (req, res) => {\r\n  const payload = req.body || {};\r\n  // Handle Safaricom Daraja STK push callback structure if present\r\n  try {\r\n    const stk = payload?.Body?.stkCallback || payload?.stkCallback || null;\r\n    if (stk && stk?.CheckoutRequestID) {\r\n      const checkout = stk.CheckoutRequestID;\r\n      const resultCode = stk.ResultCode;\r\n      const resultDesc = stk.ResultDesc || stk.ResultDescription || null;\r\n      // find payment by provider checkout id\r\n      const payment = await getPaymentByProviderCheckout(checkout);\r\n      if (!payment) {\r\n        console.warn('Webhook: could not find payment for checkout', checkout);\r\n        return res.json({ ok: true, note: 'no payment found' });\r\n      }\r\n      const status = (resultCode === 0 || resultCode === '0') ? 'success' : 'failed';\r\n      const provider_tx_id = stk?.CallbackMetadata?.Item?.find?.(i => i.Name === 'MpesaReceiptNumber')?.Value || null;\r\n      const metadata = { daraja: stk, raw: payload };\r\n      const updated = await handleMpesaCallback({ tx_ref: payment.tx_ref, status, provider_tx_id, metadata });\r\n      if (updated && updated.status === 'success' && updated.user_id) {\r\n        try {\r\n          await bot.telegram.sendMessage(updated.user_id, `Payment received. Thank you ΓÇö your account is now active.`);\r\n          await upsertUser({ user_id: updated.user_id, status: 'active' });\r\n        } catch (err) {\r\n          console.error('Failed to notify user after payment', err);\r\n        }\r\n      }\r\n      return res.json({ ok: true, updated });\r\n    }\r\n\r\n    // Generic fallback expecting tx_ref\r\n    const tx_ref = payload.tx_ref || payload.reference || payload.checkoutRequestID || null;\r\n    const status = payload.status || payload.result || null;\r\n    const provider_tx_id = payload.provider_tx_id || payload.transaction_id || null;\r\n    const metadata = payload.metadata || payload;\r\n    if (!tx_ref) return res.status(400).json({ error: 'missing tx_ref' });\r\n    const updated = await handleMpesaCallback({ tx_ref, status, provider_tx_id, metadata });\r\n    if (updated && updated.status === 'success' && updated.user_id) {\r\n      try {\r\n        await bot.telegram.sendMessage(updated.user_id, `Payment received. Thank you ΓÇö your account is now active.`);\r\n        await upsertUser({ user_id: updated.user_id, status: 'active' });\r\n      } catch (err) {\r\n        console.error('Failed to notify user after payment', err);\r\n      }\r\n    }\r\n    return res.json({ ok: true, updated });\r\n  } catch (err) {\r\n    console.error('Webhook handling error', err);\r\n    return res.status(500).json({ error: 'internal' });\r\n  }\r\n});\r\n\r\n// Bot's internal webhook handler runs on 3001 by default to avoid colliding\r\n// with the standalone `server.cjs` webhook process which commonly uses port 3000.\r\nconst webhookPort = process.env.WEBHOOK_PORT ? Number(process.env.WEBHOOK_PORT) : (process.env.PORT ? Number(process.env.PORT) : 3001);\r\napp.listen(webhookPort, () => console.log(`Webhook server listening on port ${webhookPort}`));\r\n\r\nbot.launch();\r\n\r\nconsole.log('Bot started.');\r\n\r\nprocess.once('SIGINT', () => bot.stop('SIGINT'));\r\nprocess.once('SIGTERM', () => bot.stop('SIGTERM'));\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\bot\\utils\\safeEdit.js","messages":[{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":32,"column":149,"nodeType":"BlockStatement","messageId":"unexpected","endLine":32,"endColumn":151,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[1506,1506],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export async function safeEdit(ctx, newText, newMarkup) {\r\n  try {\r\n    // Attach a freshness stamp (optional) ΓÇö using HH:MM:SS to indicate refresh time\r\n    const stamp = new Date().toISOString().slice(11,19); // HH:MM:SS\r\n    const stampedText = `${newText}\\n\\n_Refreshed ${stamp}_`;\r\n\r\n    // Try ctx.editMessageText if available (Telegraf-style)\r\n    if (ctx && typeof ctx.editMessageText === 'function') {\r\n      await ctx.editMessageText(stampedText, {\r\n        parse_mode: 'Markdown',\r\n        reply_markup: newMarkup\r\n      });\r\n      return;\r\n    }\r\n\r\n    // If ctx is raw bot instance with chat/message ids\r\n    if (ctx && ctx.chat && ctx.message && typeof ctx.bot !== 'undefined') {\r\n      // try to edit via bot\r\n      await ctx.bot.editMessageText(stampedText, { chat_id: ctx.chat.id, message_id: ctx.message.message_id, parse_mode: 'Markdown', reply_markup: newMarkup });\r\n      return;\r\n    }\r\n\r\n    // As a last resort, try to send a new message if we cannot edit\r\n    if (ctx && typeof ctx.reply === 'function') {\r\n      await ctx.reply(newText, { reply_markup: newMarkup });\r\n      return;\r\n    }\r\n  } catch (err) {\r\n    const msg = String(err?.description || err?.message || err || '');\r\n    const isNotModified = msg.includes('message is not modified') || msg.includes('Bad Request: message is not modified');\r\n    if (isNotModified) {\r\n      try { if (ctx && typeof ctx.answerCbQuery === 'function') await ctx.answerCbQuery('Already up to date Γ£à', { show_alert: false }); } catch (_) {}\r\n      return;\r\n    }\r\n\r\n    const isCantEdit = msg.includes('message to edit not found') || msg.includes(\"message can't be edited\") || msg.includes('message to edit has no text');\r\n    if (isCantEdit) {\r\n      try {\r\n        if (ctx && typeof ctx.reply === 'function') {\r\n          await ctx.reply(newText, { reply_markup: newMarkup });\r\n          return;\r\n        }\r\n      } catch (e) {\r\n        // fallthrough\r\n      }\r\n    }\r\n\r\n    // Unexpected: rethrow so callers can log\r\n    throw err;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\commands\\menu-handler.impl.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\commands\\menu-handler.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\config\\cache-config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\database\\db.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\database\\migrations.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'db' is defined but never used.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":12}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Database Migrations\n * Create all tables and indexes\n */\n\nimport { db } from \"./db.js\";\nimport { Logger } from \"../utils/logger.js\";\n\nconst logger = new Logger(\"Migrations\");\n\nexport async function runMigrations() {\n  try {\n    logger.info(\"Running migrations...\");\n\n    // Create tables (Drizzle will handle this via schema)\n    // Tables are auto-created when db instance is initialized\n\n    logger.info(\"Γ£à Migrations complete\");\n    return true;\n  } catch (err) {\n    logger.error(\"Migration failed\", err);\n    return false;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\database\\schema.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\handlers-betslip.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\handlers-branding.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'logger' is assigned a value but never used.","line":8,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":13}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Branded Handlers - All responses use BETRIX branding\n */\n\nimport { BrandingService } from \"./services/branding-service.js\";\nimport { Logger } from \"./utils/logger.js\";\n\nconst logger = new Logger(\"BrandedHandlers\");\n\nclass BrandedHandlers {\n  constructor(telegram, userService, gemini) {\n    this.telegram = telegram;\n    this.userService = userService;\n    this.gemini = gemini;\n  }\n\n  /**\n   * Send branded welcome\n   */\n  async sendBrandedWelcome(chatId, userName) {\n    const welcome = BrandingService.getWelcome(userName);\n    await this.telegram.sendMessage(chatId, welcome);\n  }\n\n  /**\n   * Send branded menu\n   */\n  async sendBrandedMenu(chatId) {\n    const menu = BrandingService.getMenu();\n    await this.telegram.sendMessage(chatId, menu);\n  }\n\n  /**\n   * Send branded success\n   */\n  async sendSuccess(chatId, message) {\n    const branded = BrandingService.success(message);\n    await this.telegram.sendMessage(chatId, branded);\n  }\n\n  /**\n   * Send branded error\n   */\n  async sendError(chatId, message) {\n    const branded = BrandingService.error(message);\n    await this.telegram.sendMessage(chatId, branded);\n  }\n\n  /**\n   * Send branded warning\n   */\n  async sendWarning(chatId, message) {\n    const branded = BrandingService.warning(message);\n    await this.telegram.sendMessage(chatId, branded);\n  }\n\n  /**\n   * Send branded info\n   */\n  async sendInfo(chatId, message) {\n    const branded = BrandingService.info(message);\n    await this.telegram.sendMessage(chatId, branded);\n  }\n\n  /**\n   * Send branded help\n   */\n  async sendBrandedHelp(chatId) {\n    const help = `${BrandingService.ICONS.help} <b>BETRIX HELP</b>\n\n${BrandingService.menuItem(\"/start\", \"Welcome message\", BrandingService.ICONS.betrix)}\n${BrandingService.menuItem(\"/menu\", \"All commands\", BrandingService.ICONS.menu)}\n${BrandingService.menuItem(\"/live\", \"Live matches\", BrandingService.ICONS.live)}\n${BrandingService.menuItem(\"/odds\", \"Betting odds\", BrandingService.ICONS.odds)}\n${BrandingService.menuItem(\"/analyze\", \"AI analysis\", BrandingService.ICONS.analyze)}\n${BrandingService.menuItem(\"/predict\", \"Predictions\", BrandingService.ICONS.predict)}\n${BrandingService.menuItem(\"/coach\", \"Betting coach\", BrandingService.ICONS.coach)}\n${BrandingService.menuItem(\"/leaderboard\", \"Rankings\", BrandingService.ICONS.leaderboard)}\n${BrandingService.menuItem(\"/achievements\", \"Badges\", BrandingService.ICONS.achievement)}\n${BrandingService.menuItem(\"/pricing\", \"Plans\", BrandingService.ICONS.pricing)}\n${BrandingService.menuItem(\"/refer\", \"Referrals\", BrandingService.ICONS.refer)}\n\n${BrandingService.getFooter()}`;\n\n    await this.telegram.sendMessage(chatId, help);\n  }\n\n  /**\n   * Send branded feature showcase\n   */\n  async sendBrandedFeatureShowcase(chatId) {\n    const showcase = `≡ƒÆÄ <b>BETRIX FEATURES</b>\n\n${BrandingService.getFeatureDescription(\"leaderboard\")}\n\n${BrandingService.getFeatureDescription(\"coach\")}\n\n${BrandingService.getFeatureDescription(\"notifications\")}\n\n${BrandingService.getFeatureDescription(\"achievements\")}\n\n${BrandingService.getFeatureDescription(\"betslips\")}\n\n${BrandingService.getFooter()}`;\n\n    await this.telegram.sendMessage(chatId, showcase);\n  }\n\n  /**\n   * Send branded live matches\n   */\n  async sendBrandedLiveMatches(chatId, matches) {\n    let text = `${BrandingService.ICONS.live} <b>LIVE MATCHES NOW</b>\\n\\n`;\n\n    if (!matches || matches.length === 0) {\n      text += `No matches currently live.\\nCheck again in a few minutes!`;\n    } else {\n      matches.forEach((m, i) => {\n        text += `${i + 1}. ${m.homeTeam} vs ${m.awayTeam}\\n`;\n        text += `   Score: ${m.score || \"TBA\"}\\n`;\n        text += `   Time: ${m.status}\\n\\n`;\n      });\n    }\n\n    text += BrandingService.getFooter();\n    await this.telegram.sendMessage(chatId, text);\n  }\n\n  /**\n   * Send branded standings\n   */\n  async sendBrandedStandings(chatId, standings, league) {\n    let text = `${BrandingService.ICONS.standings} <b>${league} STANDINGS</b>\\n\\n`;\n\n    standings.forEach((team, i) => {\n      text += `${i + 1}. ${team.name} - ${team.points}pts\\n`;\n    });\n\n    text += BrandingService.getFooter();\n    await this.telegram.sendMessage(chatId, text);\n  }\n\n  /**\n   * Send branded prediction\n   */\n  async sendBrandedPrediction(chatId, prediction) {\n    const text = `${BrandingService.ICONS.predict} <b>AI PREDICTION</b>\n\n${prediction.analysis}\n\n${BrandingService.ICONS.pro} Confidence: ${prediction.confidence}%\n${BrandingService.ICONS.stats} Based on form analysis and historical data\n\n${BrandingService.getFooter()}`;\n\n    await this.telegram.sendMessage(chatId, text);\n  }\n\n  /**\n   * Send branded pricing\n   */\n  async sendBrandedPricing(chatId) {\n    const pricing = `${BrandingService.ICONS.pricing} <b>BETRIX PLANS</b>\n\n${BrandingService.ICONS.brand} <b>Free</b>\nΓÇó Basic match info\nΓÇó Live odds\nΓÇó Community leaderboard\n\n${BrandingService.ICONS.member} <b>Member - KES 150</b>\nΓÇó AI predictions\nΓÇó Personal stats\nΓÇó Member-only tips\n\n${BrandingService.ICONS.pro} <b>VVIP - KES 200-2,500</b>\nΓÇó Professional dossiers\nΓÇó AI Betting Coach\nΓÇó Premium notifications\nΓÇó Early betslips\nΓÇó Seasonal analysis\n\n/upgrade to get started!${BrandingService.getFooter()}`;\n\n    await this.telegram.sendMessage(chatId, pricing);\n  }\n\n  /**\n   * Send branded achievement\n   */\n  async sendBrandedAchievement(chatId, achievement) {\n    const text = `≡ƒÄë <b>ACHIEVEMENT UNLOCKED</b>\n\n${achievement.emoji} ${achievement.name}\n${achievement.desc}\n\nGreat job! Keep up the momentum!${BrandingService.getFooter()}`;\n\n    await this.telegram.sendMessage(chatId, text);\n  }\n\n  /**\n   * Send branded leaderboard\n   */\n  async sendBrandedLeaderboard(chatId, leaderboard) {\n    let text = `${BrandingService.ICONS.leaderboard} <b>TOP PLAYERS TODAY</b>\\n\\n`;\n\n    leaderboard.forEach((player, i) => {\n      const medal = i === 0 ? \"≡ƒÑç\" : i === 1 ? \"≡ƒÑê\" : i === 2 ? \"≡ƒÑë\" : `${i + 1}.`;\n      text += `${medal} ${player.name} - ${player.points}pts (${player.accuracy}%)\\n`;\n    });\n\n    text += BrandingService.getFooter();\n    await this.telegram.sendMessage(chatId, text);\n  }\n}\n\nexport { BrandedHandlers };\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\handlers-global.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'UIBuilder' is defined but never used.","line":8,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":19},{"ruleId":"no-unused-vars","severity":2,"message":"'logger' is assigned a value but never used.","line":11,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":13},{"ruleId":"no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":23,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":34},{"ruleId":"no-unused-vars","severity":2,"message":"'country' is assigned a value but never used.","line":58,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":58,"endColumn":18},{"ruleId":"no-unused-vars","severity":2,"message":"'user' is assigned a value but never used.","line":123,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":123,"endColumn":15}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Global Signup Handlers\n * Multi-country, multi-currency, multi-language signup flow\n */\n\nimport { Logger } from \"./utils/logger.js\";\nimport { GlobalService } from \"./services/global-service.js\";\nimport { UIBuilder } from \"./utils/ui-builder.js\";\nimport { I18n } from \"./utils/i18n.js\";\n\nconst logger = new Logger(\"GlobalHandlers\");\n\nclass GlobalSignupHandler {\n  constructor(telegram, userService, otp) {\n    this.telegram = telegram;\n    this.userService = userService;\n    this.otp = otp;\n  }\n\n  /**\n   * Step 1: Ask for country\n   */\n  async askCountry(chatId, userId) {\n    const text = `≡ƒîì <b>Welcome to BETRIX</b>\\n\\n` +\n      `Where are you joining from?\\n\\n` +\n      `This helps us show the right currency and payment methods.`;\n\n    const kb = GlobalService.buildCountryKeyboard();\n    await this.telegram.sendMessage(chatId, text, { reply_markup: kb });\n  }\n\n  /**\n   * Step 2: Country selected, ask language\n   */\n  async askLanguage(chatId, userId, countryCode) {\n    const country = GlobalService.getCountry(countryCode);\n    if (!country) {\n      await this.telegram.sendMessage(chatId, \"Γ¥î Invalid country. Try again.\");\n      return this.askCountry(chatId, userId);\n    }\n\n    await this.userService.saveUser(userId, { country: countryCode });\n\n    const text = `${country.flag} <b>${country.name}</b>\\n\\n` +\n      `Choose your language:`;\n\n    const kb = GlobalService.buildLanguageKeyboard(countryCode);\n    await this.telegram.sendMessage(chatId, text, { reply_markup: kb });\n  }\n\n  /**\n   * Step 3: Language selected, ask for plan\n   */\n  async askPlan(chatId, userId, language) {\n    const user = await this.userService.getUser(userId);\n    await this.userService.saveUser(userId, { language });\n\n    const country = GlobalService.getCountry(user.country);\n    const pricing = {\n      member: GlobalService.getLocalPricing(\"member\", user.country),\n      vvip_day: GlobalService.getLocalPricing(\"vvip_day\", user.country),\n      vvip_week: GlobalService.getLocalPricing(\"vvip_week\", user.country),\n      vvip_month: GlobalService.getLocalPricing(\"vvip_month\", user.country),\n    };\n\n    const text = `≡ƒÆÄ <b>Choose Your Plan</b>\\n\\n` +\n      `≡ƒÄü <b>Free</b>\\n` +\n      `Γö£ΓöÇ Live matches\\n` +\n      `Γö£ΓöÇ Basic odds\\n` +\n      `ΓööΓöÇ AI analysis\\n\\n` +\n      `≡ƒæñ <b>Member (One-time)</b>\\n` +\n      `Γö£ΓöÇ All Free features\\n` +\n      `Γö£ΓöÇ Alerts & stats\\n` +\n      `ΓööΓöÇ ${pricing.member.displayText}\\n\\n` +\n      `≡ƒÆÄ <b>VVIP (Subscription)</b>\\n` +\n      `Γö£ΓöÇ Professional analysis\\n` +\n      `Γö£ΓöÇ Betting coach\\n` +\n      `Γö£ΓöÇ Daily: ${pricing.vvip_day.displayText}\\n` +\n      `Γö£ΓöÇ Weekly: ${pricing.vvip_week.displayText}\\n` +\n      `ΓööΓöÇ Monthly: ${pricing.vvip_month.displayText}`;\n\n    const kb = {\n      inline_keyboard: [\n        [{ text: \"≡ƒÄü Free\", callback_data: \"plan:free\" }],\n        [{ text: `≡ƒæñ Member - ${pricing.member.currency} ${pricing.member.amount}`, callback_data: \"plan:member\" }],\n        [\n          { text: `≡ƒÆÄ Day - ${pricing.vvip_day.currency} ${pricing.vvip_day.amount}`, callback_data: \"plan:vvip_day\" },\n        ],\n        [\n          { text: `≡ƒÆÄ Week - ${pricing.vvip_week.currency} ${pricing.vvip_week.amount}`, callback_data: \"plan:vvip_week\" },\n        ],\n        [\n          { text: `≡ƒÆÄ Month - ${pricing.vvip_month.currency} ${pricing.vvip_month.amount}`, callback_data: \"plan:vvip_month\" },\n        ],\n      ],\n    };\n\n    await this.telegram.sendMessage(chatId, text, { reply_markup: kb });\n  }\n\n  /**\n   * Step 4: Plan selected, ask for payment method\n   */\n  async askPaymentMethod(chatId, userId, plan) {\n    const user = await this.userService.getUser(userId);\n    await this.userService.saveUser(userId, { selectedPlan: plan });\n\n    if (plan === \"free\") {\n      return this.completeSignup(chatId, userId, \"free\", null);\n    }\n\n    const text = `≡ƒÆ│ <b>How do you want to pay?</b>\\n\\n` +\n      `Available for ${GlobalService.getCountry(user.country).name}:`;\n\n    const kb = GlobalService.buildPaymentKeyboard(user.country);\n    await this.telegram.sendMessage(chatId, text, { reply_markup: kb });\n  }\n\n  /**\n   * Step 5: Payment method selected, ask for phone\n   */\n  async askPhone(chatId, userId, paymentMethod) {\n    const user = await this.userService.getUser(userId);\n    await this.userService.saveUser(userId, { paymentMethod });\n\n    const text = `≡ƒô▒ <b>Verify Your Phone</b>\\n\\n` +\n      `Enter your phone number (with country code or local format):`;\n\n    await this.telegram.sendMessage(chatId, text);\n    // State for next message will be handled in main worker\n  }\n\n  /**\n   * Step 6: Phone provided, send OTP\n   */\n  async sendOTP(chatId, userId, phone) {\n    const user = await this.userService.getUser(userId);\n\n    // Validate & format phone\n    const isValid = GlobalService.validatePhone(phone, user.country);\n    if (!isValid) {\n      await this.telegram.sendMessage(chatId, `Γ¥î Invalid phone format for ${GlobalService.getCountry(user.country).name}`);\n      return this.askPhone(chatId, userId, user.paymentMethod);\n    }\n\n    const formatted = GlobalService.formatPhone(phone, user.country);\n    const result = await this.otp.sendOTP(userId, formatted);\n\n    if (!result.success) {\n      await this.telegram.sendMessage(chatId, `Γ¥î Failed to send OTP: ${result.error}`);\n      return this.askPhone(chatId, userId, user.paymentMethod);\n    }\n\n    await this.telegram.sendMessage(chatId,\n      `Γ£à OTP sent to ${formatted}\\n\\n` +\n      `Enter the 6-digit code:`,\n    );\n    await this.userService.saveUser(userId, { phone: formatted });\n  }\n\n  /**\n   * Step 7: OTP verified, show payment processing\n   */\n  async completeSignup(chatId, userId, plan, paymentMethod) {\n    const user = await this.userService.getUser(userId);\n    const country = GlobalService.getCountry(user.country);\n\n    if (plan === \"free\") {\n      await this.userService.saveUser(userId, { tier: \"free\", signupComplete: true });\n      await this.telegram.sendMessage(chatId,\n        `Γ£à <b>Welcome to BETRIX!</b>\\n\\n` +\n        `≡ƒÄü Free tier activated\\n` +\n        `≡ƒôì ${country.flag} ${country.name}\\n` +\n        `≡ƒîÉ Language: ${I18n.supportedLanguages().includes(user.language) ? user.language : 'English'}\\n\\n` +\n        `Get started:\\n` +\n        `/menu - Main menu\\n` +\n        `/live - Live matches\\n` +\n        `/pricing - Upgrade to Member/VVIP`,\n      );\n    } else {\n      const pricing = GlobalService.getLocalPricing(plan, user.country);\n      await this.telegram.sendMessage(chatId,\n        `ΓÅ│ <b>Processing Payment</b>\\n\\n` +\n        `Amount: ${pricing.displayText}\\n` +\n        `Method: ${paymentMethod}\\n` +\n        `Status: Awaiting confirmation...\\n\\n` +\n        `This usually takes less than 1 minute.`,\n      );\n\n      // In production, integrate actual payment processing here\n      await this.userService.saveUser(userId, {\n        tier: plan.startsWith(\"vvip\") ? \"vvip\" : \"member\",\n        signupComplete: true,\n        selectedPlan: plan,\n        paymentMethod,\n      });\n\n      await this.telegram.sendMessage(chatId,\n        `Γ£à <b>Success!</b>\\n\\n` +\n        `≡ƒÆÄ ${plan === \"member\" ? \"Member\" : \"VVIP\"} tier activated\\n` +\n        `≡ƒôì ${country.flag} ${country.name}\\n` +\n        `≡ƒÆ░ Amount: ${pricing.displayText}\\n` +\n        `≡ƒîÉ Language: ${user.language.toUpperCase()}\\n\\n` +\n        `Now you have access to all premium features!\\n\\n` +\n        `/menu - Start exploring`,\n      );\n    }\n  }\n}\n\nexport { GlobalSignupHandler };\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\handlers-new-features.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'AIFallbackService' is defined but never used.","line":10,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":27},{"ruleId":"no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":28,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":28,"endColumn":34},{"ruleId":"no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":105,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":105,"endColumn":33},{"ruleId":"no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":128,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":128,"endColumn":36},{"ruleId":"no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":140,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":140,"endColumn":36},{"ruleId":"no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":149,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":149,"endColumn":34},{"ruleId":"no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":158,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":158,"endColumn":40},{"ruleId":"no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":167,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":167,"endColumn":35}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * BETRIX New Features Handlers\n * Meme, Crypto, News, Tips with full branding\n */\n\nimport { Logger } from \"./utils/logger.js\";\nimport { MemeService } from \"./services/meme-service.js\";\nimport { CryptoPredictionsService } from \"./services/crypto-predictions-service.js\";\nimport { NewsService } from \"./services/news-service.js\";\nimport { AIFallbackService } from \"./services/ai-fallback-service.js\";\nimport { ContentGenerationService } from \"./services/content-generation-service.js\";\nimport { BrandingService } from \"./services/branding-service.js\";\n\nconst logger = new Logger(\"NewFeatures\");\n\nclass NewFeaturesHandlers {\n  constructor(telegram, userService, gemini) {\n    this.telegram = telegram;\n    this.userService = userService;\n    this.gemini = gemini;\n    this.cryptoService = new CryptoPredictionsService();\n    this.newsService = new NewsService();\n  }\n\n  /**\n   * /meme - Random betting meme\n   */\n  async handleMeme(chatId, userId) {\n    try {\n      const meme = MemeService.generateTextMeme(\"Your Team\", 2.5, \"The Favorites\");\n      \n      const text = `${BrandingService.ICONS.achievement} <b>BETRIX Meme of the Moment</b>\n\n${MemeService.formatMeme(meme)}\n\n≡ƒÿé Too relatable? Share this with your betting crew!`;\n\n      return this.telegram.sendMessage(chatId, text);\n    } catch (err) {\n      logger.error(\"Meme handler error\", err);\n      return this.telegram.sendMessage(\n        chatId,\n        `${BrandingService.ICONS.error} Meme engine temporarily down. Try again!`\n      );\n    }\n  }\n\n  /**\n   * /crypto [symbol] - Crypto prediction\n   */\n  async handleCrypto(chatId, userId, symbol = \"bitcoin\") {\n    try {\n      const symbol_lower = (symbol || \"bitcoin\").toLowerCase();\n      const prediction = await this.cryptoService.predictCryptoPrice(symbol_lower);\n\n      if (!prediction) {\n        return this.telegram.sendMessage(\n          chatId,\n          `${BrandingService.ICONS.error} <b>Crypto Not Found</b>\\n\\nTry: /crypto bitcoin or /crypto ethereum`\n        );\n      }\n\n      const text = `${BrandingService.ICONS.special} <b>BETRIX Crypto Analysis</b>\n\n${this.cryptoService.formatPrediction(prediction)}\n\n≡ƒÆí <i>Crypto predictions based on 24h momentum. Not financial advice.</i>`;\n\n      return this.telegram.sendMessage(chatId, text);\n    } catch (err) {\n      logger.error(\"Crypto handler error\", err);\n      return this.telegram.sendMessage(\n        chatId,\n        `${BrandingService.ICONS.error} Unable to fetch crypto data right now.`\n      );\n    }\n  }\n\n  /**\n   * /news - Latest sports news\n   */\n  async handleNews(chatId, userId, query = \"football\") {\n    try {\n      const articles = await this.newsService.getSportsNews(query || \"football\");\n\n      const text = `${BrandingService.ICONS.info} <b>BETRIX Sports News</b>\n\n${this.newsService.formatNews(articles)}\n\n≡ƒôû Stay informed to make better betting decisions!`;\n\n      return this.telegram.sendMessage(chatId, text);\n    } catch (err) {\n      logger.error(\"News handler error\", err);\n      return this.telegram.sendMessage(\n        chatId,\n        `${BrandingService.ICONS.error} News service temporarily unavailable.`\n      );\n    }\n  }\n\n  /**\n   * /tip - Random betting strategy tip\n   */\n  async handleTip(chatId, userId) {\n    try {\n      const tip = ContentGenerationService.generateBettingTip();\n\n      const text = `${BrandingService.ICONS.tips} <b>BETRIX Strategy Tip</b>\n\n${tip}\n\n≡ƒÄ» Apply this wisdom to your next bet!`;\n\n      return this.telegram.sendMessage(chatId, text);\n    } catch (err) {\n      logger.error(\"Tip handler error\", err);\n      return this.telegram.sendMessage(\n        chatId,\n        `${BrandingService.ICONS.error} Tip service down. Check back later!`\n      );\n    }\n  }\n\n  /**\n   * Enhanced /menu with modern design\n   */\n  async enhancedMenu(chatId, userId) {\n    const { ModernMenuService } = await import(\"./services/modern-menu-service.js\");\n    const menuData = ModernMenuService.mainMenu();\n    \n    return this.telegram.sendMessage(chatId, menuData.text, {\n      reply_markup: { inline_keyboard: menuData.keyboard }\n    });\n  }\n\n  /**\n   * Enhanced /help with modern design\n   */\n  async enhancedHelp(chatId, userId) {\n    const { ModernMenuService } = await import(\"./services/modern-menu-service.js\");\n    const text = ModernMenuService.helpMenu();\n    return this.telegram.sendMessage(chatId, text);\n  }\n  \n  /**\n   * Sports menu\n   */\n  async sportsMenu(chatId, userId) {\n    const { ModernMenuService } = await import(\"./services/modern-menu-service.js\");\n    const text = ModernMenuService.sportsMenu();\n    return this.telegram.sendMessage(chatId, text);\n  }\n\n  /**\n   * Free features menu\n   */\n  async freeFeaturesMenu(chatId, userId) {\n    const { ModernMenuService } = await import(\"./services/modern-menu-service.js\");\n    const text = ModernMenuService.freeFeaturesMenu();\n    return this.telegram.sendMessage(chatId, text);\n  }\n\n  /**\n   * Premium features menu\n   */\n  async premiumMenu(chatId, userId) {\n    const { ModernMenuService } = await import(\"./services/modern-menu-service.js\");\n    const text = ModernMenuService.premiumMenu();\n    return this.telegram.sendMessage(chatId, text);\n  }\n}\n\nexport { NewFeaturesHandlers };\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\handlers-tier.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'escapeHtml' is defined but never used.","line":8,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":20},{"ruleId":"no-unused-vars","severity":2,"message":"'logger' is assigned a value but never used.","line":10,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":13},{"ruleId":"no-unused-vars","severity":2,"message":"'tier' is assigned a value but never used.","line":23,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":15},{"ruleId":"no-unused-vars","severity":2,"message":"'tier' is assigned a value but never used.","line":57,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":57,"endColumn":15}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tier-Aware Handlers\n * Subscription-aware command responses with gating\n */\n\nimport { Logger } from \"./utils/logger.js\";\nimport { UIBuilder, EMOJIS } from \"./utils/ui-builder.js\";\nimport { escapeHtml } from \"./utils/formatters.js\";\n\nconst logger = new Logger(\"TierHandlers\");\n\nclass TierAwareHandlers {\n  constructor(handlers, gatekeeper, userService) {\n    this.handlers = handlers;\n    this.gatekeeper = gatekeeper;\n    this.userService = userService;\n  }\n\n  /**\n   * Tier-aware /live command\n   */\n  async liveWithTier(chatId, userId) {\n    const tier = await this.gatekeeper.getUserTier(userId);\n    return this.handlers.live(chatId, userId);\n  }\n\n  /**\n   * Tier-aware /odds command\n   */\n  async oddsWithTier(chatId, userId, fixtureId) {\n    const tier = await this.gatekeeper.getUserTier(userId);\n\n    if (!fixtureId) {\n      return this.handlers.telegram.sendMessage(\n        chatId,\n        `${EMOJIS.odds} <b>Betting Odds</b>\\n\\nUsage: /odds [fixture-id]`\n      );\n    }\n\n    try {\n      const data = await this.handlers.apiFootball.getOdds(fixtureId);\n      const text = UIBuilder.formatOdds(data.response?.[0], tier);\n      return this.handlers.telegram.sendMessage(chatId, text);\n    } catch (err) {\n      return this.handlers.telegram.sendMessage(chatId, \"Unable to fetch odds\");\n    }\n  }\n\n  /**\n   * Tier-aware /analysis command\n   */\n  async analysisWithTier(chatId, userId, matchQuery) {\n    if (!(await this.gatekeeper.enforceAccess(chatId, userId, \"analysis\"))) {\n      return;\n    }\n\n    const tier = await this.gatekeeper.getUserTier(userId);\n\n    if (!matchQuery) {\n      return this.handlers.telegram.sendMessage(\n        chatId,\n        `${EMOJIS.analyze} Match Analysis\\n\\nUsage: /analyze [home] vs [away]`\n      );\n    }\n\n    try {\n      let analysis = await this.handlers.gemini.chat(\n        `Analyze ${matchQuery} with form, odds, and key factors.`,\n        {}\n      );\n\n      analysis = await this.gatekeeper.decorateResponse(chatId, userId, \"analysis\", analysis);\n      return this.handlers.telegram.sendMessage(chatId, analysis);\n    } catch (err) {\n      return this.handlers.telegram.sendMessage(chatId, \"Analysis unavailable\");\n    }\n  }\n\n  /**\n   * Tier-aware /predictions command\n   */\n  async predictionsWithTier(chatId, userId, matchQuery) {\n    if (!(await this.gatekeeper.enforceAccess(chatId, userId, \"predictions\"))) {\n      return;\n    }\n\n    const tier = await this.gatekeeper.getUserTier(userId);\n\n    if (!matchQuery) {\n      return this.handlers.telegram.sendMessage(\n        chatId,\n        `${EMOJIS.predict} Predictions\\n\\nUsage: /predict [home] vs [away]`\n      );\n    }\n\n    try {\n      const prediction = await this.handlers.predictor?.predictMatch(\n        matchQuery.split(\" vs \")[0],\n        matchQuery.split(\" vs \")[1]\n      );\n\n      let text = UIBuilder.formatPrediction(prediction, tier);\n      return this.handlers.telegram.sendMessage(chatId, text);\n    } catch (err) {\n      return this.handlers.telegram.sendMessage(chatId, \"Predictions unavailable\");\n    }\n  }\n\n  /**\n   * Tier-aware /dossier command\n   */\n  async dossierWithTier(chatId, userId, matchQuery) {\n    if (!(await this.gatekeeper.enforceAccess(chatId, userId, \"dossier\"))) {\n      return;\n    }\n\n    if (!matchQuery) {\n      return this.handlers.telegram.sendMessage(\n        chatId,\n        `≡ƒôï Match Dossier\\n\\nUsage: /dossier [home] vs [away]`\n      );\n    }\n\n    try {\n      const dossier = await this.handlers.premium?.generateMatchDossier(matchQuery);\n      const header = UIBuilder.formatDossierHeader({ teams: { home: { name: matchQuery } } }, \"vvip\");\n      return this.handlers.telegram.sendMessage(chatId, `${header}\\n${dossier}`);\n    } catch (err) {\n      return this.handlers.telegram.sendMessage(chatId, \"Dossier unavailable\");\n    }\n  }\n\n  /**\n   * Tier-aware /coach command\n   */\n  async coachWithTier(chatId, userId) {\n    if (!(await this.gatekeeper.enforceAccess(chatId, userId, \"coach\"))) {\n      return;\n    }\n\n    try {\n      const stats = await this.handlers.analytics?.getUserStats(userId);\n      const advice = await this.handlers.premium?.getCoachAdvice(stats);\n      return this.handlers.telegram.sendMessage(chatId, `≡ƒÅå <b>Betting Coach</b>\\n\\n${advice}`);\n    } catch (err) {\n      return this.handlers.telegram.sendMessage(chatId, \"Coaching unavailable\");\n    }\n  }\n\n  /**\n   * Tier-aware /trends command\n   */\n  async trendsWithTier(chatId, userId, league = \"premier league\") {\n    if (!(await this.gatekeeper.enforceAccess(chatId, userId, \"trends\"))) {\n      return;\n    }\n\n    try {\n      const trends = await this.handlers.premium?.analyzeSeasonalTrends(league);\n      return this.handlers.telegram.sendMessage(chatId, `≡ƒôè <b>Seasonal Trends: ${league}</b>\\n\\n${trends}`);\n    } catch (err) {\n      return this.handlers.telegram.sendMessage(chatId, \"Trends unavailable\");\n    }\n  }\n\n  /**\n   * Show features by tier\n   */\n  async showFeatures(chatId, userId) {\n    const tier = await this.gatekeeper.getUserTier(userId);\n    const text = UIBuilder.buildFeaturesList(tier);\n    return this.handlers.telegram.sendMessage(chatId, text);\n  }\n\n  /**\n   * Show tier menu\n   */\n  async showTierMenu(chatId, userId) {\n    const tier = await this.gatekeeper.getUserTier(userId);\n    const user = await this.userService.getUser(userId);\n\n    let text = `${EMOJIS.premium} <b>Your Account</b>\\n\\n`;\n    text += `≡ƒôè Tier: ${tier === \"vvip\" ? \"≡ƒÆÄ VVIP\" : tier === \"member\" ? \"≡ƒæñ Member\" : \"≡ƒÄü Free\"}\\n`;\n    text += `≡ƒæñ Name: ${user?.name || \"ΓÇö\"}\\n`;\n    text += `≡ƒîì Country: ${user?.country || \"ΓÇö\"}\\n`;\n\n    if (tier === \"vvip\" && user?.vvip_expires_at) {\n      text += `ΓÅ░ Expires: ${new Date(user.vvip_expires_at).toLocaleDateString()}\\n`;\n    }\n\n    text += `\\n<b>Available Features:</b>\\n`;\n    text += UIBuilder.buildFeaturesList(tier).split(\"<b>Feature Access</b>\\n\\n\")[1];\n\n    const kb = {\n      inline_keyboard: [\n        [{ text: \"≡ƒÆ│ Upgrade Plan\", callback_data: \"show:subscription\" }],\n        [{ text: \"≡ƒôï Features\", callback_data: \"show:features\" }],\n        [{ text: `${EMOJIS.back} Back`, callback_data: \"menu:main\" }],\n      ],\n    };\n\n    return this.handlers.telegram.sendMessage(chatId, text, { reply_markup: kb });\n  }\n\n  /**\n   * Tier-aware standings\n   */\n  async standingsWithTier(chatId, userId, league = \"39\") {\n    const tier = await this.gatekeeper.getUserTier(userId);\n\n    try {\n      const data = await this.handlers.apiFootball?.getStandings(league, new Date().getFullYear());\n      const standings = data.response?.[0]?.league?.standings?.[0] || [];\n      const text = UIBuilder.formatStandings(standings, tier);\n      return this.handlers.telegram.sendMessage(chatId, text);\n    } catch (err) {\n      return this.handlers.telegram.sendMessage(chatId, \"Standings unavailable\");\n    }\n  }\n}\n\nexport { TierAwareHandlers };\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\handlers-web-features.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\handlers.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'formatList' is defined but never used.","line":7,"column":41,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":51},{"ruleId":"no-unused-vars","severity":2,"message":"'userId' is defined but never used.","line":83,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":83,"endColumn":28},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":116,"column":22,"nodeType":"BlockStatement","messageId":"unexpected","endLine":116,"endColumn":24,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[4613,4613],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Comprehensive command handlers with Gemini AI integration\n * Every command has intelligent responses and fallbacks\n */\n\nimport { Logger } from \"./utils/logger.js\";\nimport { ICONS, escapeHtml, pickRandom, formatList, MEMES, STRATEGY_TIPS } from \"./utils/formatters.js\";\nimport { CONFIG } from \"./config.js\";\n\nconst logger = new Logger(\"Handlers\");\n\nclass BotHandlers {\n  constructor(telegram, userService, apiFootball, gemini, redis, freeSports = null, extras = {}) {\n    this.telegram = telegram;\n    this.userService = userService;\n    this.apiFootball = apiFootball;\n    this.gemini = gemini;\n    this.redis = redis;\n    this.freeSports = freeSports;\n    // optional extra free-data services\n    this.openLiga = extras.openLiga || null;\n    this.rss = extras.rss || null;\n    this.scorebat = extras.scorebat || null;\n    this.footballDataService = extras.footballData || null;\n    this.scrapers = extras.scrapers || null;\n  }\n\n  // ===== START & MENU =====\n\n  async start(chatId, userId) {\n    const user = await this.userService.getUser(userId) || {};\n    \n    if (user?.signupComplete) {\n      const welcome = await this.gemini.chat(\n        `User \"${user.name}\" returned to BETRIX. Give a warm, personalized 1-line greeting.`,\n        { user }\n      );\n      return this.telegram.sendMessage(\n        chatId,\n        `≡ƒæï <b>Welcome back!</b>\\n\\n${welcome}\\n\\n≡ƒôî Use /menu to explore.`\n      );\n    }\n\n    const intro = `${ICONS.brand} <b>BETRIX ΓÇö Global Sports AI</b>\\n\\n` +\n      `Neutral analysis. No hype. Just insights.\\n\\n` +\n      `${pickRandom(MEMES)}\\n\\n` +\n      `<b>Get started:</b> /signup`;\n\n    return this.telegram.sendMessage(chatId, intro);\n  }\n\n  async menu(chatId, userId) {\n    const user = await this.userService.getUser(userId);\n    const isVVIP = user && this.userService.isVVIP(user);\n\n    const text =\n      `${ICONS.menu} <b>BETRIX Menu</b>\\n\\n` +\n      `${ICONS.live} /live - Live now\\n` +\n      `${ICONS.standings} /standings - Tables\\n` +\n      `${ICONS.odds} /odds - Betting odds\\n` +\n      `${ICONS.tips} /tips - Smart tips\\n` +\n      `${ICONS.analysis} /analyze - Match analysis\\n` +\n      `${ICONS.pricing} /pricing - Plans\\n` +\n      `${isVVIP ? `${ICONS.vvip} /vvip - Premium\\n` : \"\"}` +\n      `${user?.signupComplete ? `${ICONS.status} /status - Account\\n` : `${ICONS.signup} /signup - Join\\n`}` +\n      `${ICONS.refer} /refer - Earn\\n` +\n      `${ICONS.help} /help - Commands`;\n\n    const kb = {\n      inline_keyboard: [\n        [{ text: `${ICONS.live} Live`, callback_data: \"CMD:live\" }],\n        [{ text: `${ICONS.standings} Standings`, callback_data: \"CMD:standings\" }],\n        [{ text: `${ICONS.tips} Tips`, callback_data: \"CMD:tips\" }],\n        [{ text: `${ICONS.pricing} Pricing`, callback_data: \"CMD:pricing\" }],\n      ],\n    };\n\n    return this.telegram.sendMessage(chatId, text, { reply_markup: kb });\n  }\n\n  // ===== LIVE & STANDINGS =====\n\n  async live(chatId, userId) {\n    try {\n      const data = await this.apiFootball.getLive();\n\n      if (!data?.response?.length) {\n        // Try OpenLigaDB free fallback\n        if (this.openLiga) {\n          try {\n            const league = 'bl1';\n            const recent = await this.openLiga.getRecentMatches(league, new Date().getFullYear(), 3).catch(()=>[]);\n            if (recent && recent.length) {\n              const text = `${ICONS.live} <b>Live / Recent (fallback)</b>\\n\\n` +\n                recent.slice(0, 8).map((m, i) => {\n                  const home = m.Team1?.Name || m.Team1?.teamName || m.Team1 || m.name || m.home || m.HomeTeam || 'Home';\n                  const away = m.Team2?.Name || m.Team2?.teamName || m.Team2 || m.away || m.AwayTeam || 'Away';\n                  const score = (m.PointsTeam1 != null && m.PointsTeam2 != null) ? `${m.PointsTeam1}-${m.PointsTeam2}` : '-';\n                  return `${i+1}. ${home} <b>${score}</b> ${away}`;\n                }).join('\\n');\n              return this.telegram.sendMessage(chatId, text);\n            }\n          } catch (e) {\n            // ignore and continue to other fallbacks\n          }\n        }\n\n        // Try football-data CSV fallback\n        if (this.footballDataService) {\n          try {\n            const fd = await this.footballDataService.fixturesFromCsv('E0', '2324').catch(()=>null);\n            if (fd && fd.fixtures && fd.fixtures.length) {\n              const sample = fd.fixtures.slice(0,6).map((f,i)=>`${i+1}. ${f.home} vs ${f.away} (${f.date||'TBD'})`).join('\\n');\n              return this.telegram.sendMessage(chatId, `${ICONS.live} <b>Upcoming (from CSV)</b>\\n\\n${sample}`);\n            }\n          } catch(e) {}\n        }\n\n        const msg = await this.gemini.chat(\"No live football matches right now. Give a friendly 2-line response.\");\n        return this.telegram.sendMessage(chatId, `${ICONS.live} ${msg}`);\n      }\n\n      const matches = data.response.slice(0, CONFIG.PAGE_SIZE);\n      const text =\n        `${ICONS.live} <b>Live Matches (${data.response.length})</b>\\n\\n` +\n        matches\n          .map((m, i) => {\n            const home = escapeHtml(m.teams?.home?.name || \"Home\");\n            const away = escapeHtml(m.teams?.away?.name || \"Away\");\n            const hs = m.goals?.home ?? \"-\";\n            const as = m.goals?.away ?? \"-\";\n            const status = m.fixture?.status?.short || \"LIVE\";\n            return `${i + 1}. ${home} <b>${hs}-${as}</b> ${away} (${status})`;\n          })\n          .join(\"\\n\") +\n        `\\n\\nΓä╣∩╕Å Tap a match for analysis or odds.`;\n\n      return this.telegram.sendMessage(chatId, text);\n    } catch (err) {\n      logger.error(\"Live error\", err);\n      const fallback = await this.gemini.chat(\n        \"Live match data temporarily unavailable. Give a brief, helpful 2-line response suggesting what they can do.\"\n      );\n      return this.telegram.sendMessage(chatId, `Γ¥î ${fallback}`);\n    }\n  }\n\n  async standings(chatId, league = \"39\") {\n    try {\n      const leagueId = this.apiFootball.constructor.normalizeLeague(league) || 39;\n      const season = new Date().getFullYear();\n\n      const data = await this.apiFootball.getStandings(leagueId, season);\n\n      if (!data?.response?.[0]?.league?.standings) {\n        // Try free web fallback (Wikipedia)\n        if (this.freeSports) {\n          const guess = await this.freeSports.searchWiki(league);\n          if (guess) {\n            const rows = await this.freeSports.getStandings(guess, CONFIG.MAX_TABLE_ROWS || 10);\n            if (rows && rows.length) {\n              const text = `${ICONS.standings} <b>Standings ΓÇö ${guess}</b>\\n\\n` +\n                rows.map(r => `${r.rank || '-'} . ${r.team || r.raw?.[1] || 'Team'} ΓÇö ${r.points || r.raw?.slice(-1)[0] || '-'} pts`).join('\\n');\n              return this.telegram.sendMessage(chatId, text);\n            }\n          }\n        }\n        const msg = await this.gemini.chat(`No standings for league ${leagueId}. Friendly fallback.`);\n        return this.telegram.sendMessage(chatId, `${ICONS.standings} ${msg}`);\n      }\n\n      const standings = data.response[0].league.standings[0];\n      const text =\n        `${ICONS.standings} <b>Standings</b>\\n\\n` +\n        standings\n          .slice(0, CONFIG.MAX_TABLE_ROWS)\n          .map(\n            (t) =>\n              `${t.rank}. ${escapeHtml(t.team?.name)} ΓÇö ${t.points}pts (W${t.all?.win}-D${t.all?.draw}-L${t.all?.lose})`\n          )\n          .join(\"\\n\");\n\n      return this.telegram.sendMessage(chatId, text);\n    } catch (err) {\n      logger.error(\"Standings error\", err);\n      // Try OpenLigaDB fallback\n      try {\n        if (this.openLiga) {\n          const recent = await this.openLiga.getRecentMatches(league || 'bl1', new Date().getFullYear(), 4).catch(()=>[]);\n          if (recent && recent.length) {\n            const text = `${ICONS.standings} <b>Recent results (fallback)</b>\\n\\n` + recent.slice(0,10).map((r,i)=>`${i+1}. ${r.Team1?.Name||r.home||'Home'} vs ${r.Team2?.Name||r.away||'Away'} ${r.PointsTeam1!=null?`${r.PointsTeam1}-${r.PointsTeam2}`:''}`).join('\\n');\n            return this.telegram.sendMessage(chatId, text);\n          }\n        }\n      } catch (e) {\n        // ignore\n      }\n      return this.telegram.sendMessage(\n        chatId,\n        `Γ¥î Unable to fetch standings right now. Try /standings epl for Premier League.`\n      );\n    }\n  }\n\n  // ===== ODDS & ANALYSIS =====\n\n  async odds(chatId, fixtureId) {\n    if (!fixtureId) {\n      return this.telegram.sendMessage(\n        chatId,\n        `≡ƒÄ▓ <b>Betting Odds</b>\\n\\nUsage: /odds [fixture-id]\\n\\nExample: /odds 123456\\n\\nTip: Use /live to find fixture IDs.`\n      );\n    }\n\n    try {\n      const data = await this.apiFootball.getOdds(fixtureId);\n\n      if (!data?.response?.length) {\n        // No odds from API Football ΓÇö try to provide a helpful guidance using free sources\n        if (this.freeSports) {\n          // Suggest checking local bookmakers or compare via search; provide a league summary if available\n          const msg = await this.gemini.chat(\"Odds unavailable from primary provider. Provide helpful guidance about where to find odds and how to interpret them in 2 lines.\");\n          return this.telegram.sendMessage(chatId, `${ICONS.odds} ${msg}\\n\\nTip: Use /live to find recent fixtures and then try /odds [fixture-id].`);\n        }\n        const msg = await this.gemini.chat(\"No odds available for this match. Helpful fallback.\");\n        return this.telegram.sendMessage(chatId, `${ICONS.odds} ${msg}`);\n      }\n\n      const odds = data.response[0];\n      const text =\n        `${ICONS.odds} <b>Odds for ${escapeHtml(odds.fixture?.name)}</b>\\n\\n` +\n        `≡ƒÅá Home: ${odds.bookmakers?.[0]?.bets?.[0]?.values?.[0]?.odd || \"N/A\"}\\n` +\n        `≡ƒñ¥ Draw: ${odds.bookmakers?.[0]?.bets?.[0]?.values?.[1]?.odd || \"N/A\"}\\n` +\n        `≡ƒÅü Away: ${odds.bookmakers?.[0]?.bets?.[0]?.values?.[2]?.odd || \"N/A\"}\\n\\n` +\n        `≡ƒÆí Always compare odds across bookmakers for value.`;\n\n      return this.telegram.sendMessage(chatId, text);\n    } catch (err) {\n      logger.error(\"Odds error\", err);\n      return this.telegram.sendMessage(chatId, `Γ¥î Unable to fetch odds. Try again or contact support.`);\n    }\n  }\n\n  async analyze(chatId, matchQuery) {\n    if (!matchQuery) {\n      return this.telegram.sendMessage(\n        chatId,\n        `${ICONS.analysis} <b>Match Analysis</b>\\n\\nUsage: /analyze [home] vs [away]\\n\\nExample: /analyze Arsenal vs Liverpool`\n      );\n    }\n\n    try {\n      const analysis = await this.gemini.chat(\n        `Provide neutral match analysis for: ${matchQuery}. Include: form, key players, odds, confidence. Max 300 chars.`,\n        {}\n      );\n      return this.telegram.sendMessage(chatId, `${ICONS.analysis} <b>Analysis</b>\\n\\n${analysis}`);\n    } catch (err) {\n      logger.error(\"Analysis error\", err);\n      const fallback = await this.gemini.chat(\"Unable to analyze this match right now. Helpful response.\");\n      return this.telegram.sendMessage(chatId, `Γ¥î ${fallback}`);\n    }\n  }\n\n  // ===== NEWS & HIGHLIGHTS =====\n  async news(chatId) {\n    try {\n      if (this.rss) {\n        const feeds = ['https://feeds.bbci.co.uk/sport/football/rss.xml', 'https://www.theguardian.com/football/rss', 'https://www.espn.com/espn/rss/football/news'];\n        const results = await this.rss.fetchMultiple(feeds);\n        const merged = results.flatMap(r => (r.items || []).slice(0,3)).slice(0,10);\n        const text = `${ICONS.news} <b>Latest Football Headlines</b>\\n\\n` + merged.map((it,i)=>`${i+1}. ${it.title}`).join('\\n');\n        return this.telegram.sendMessage(chatId, text);\n      }\n      const msg = await this.gemini.chat('Provide recent football headlines in 3 lines.');\n      return this.telegram.sendMessage(chatId, `≡ƒô░ ${msg}`);\n    } catch (err) {\n      logger.error('News error', err);\n      return this.telegram.sendMessage(chatId, 'Γ¥î Unable to fetch news right now.');\n    }\n  }\n\n  async highlights(chatId) {\n    try {\n      if (this.scorebat) {\n        const feed = await this.scorebat.freeFeed().catch(()=>null);\n        if (feed && feed.response) {\n          const items = feed.response.slice(0,6).map((it,i)=>`${i+1}. ${it.title} - ${it.competition}`);\n          return this.telegram.sendMessage(chatId, `≡ƒÄ¼ <b>Highlights</b>\\n\\n${items.join('\\n')}`);\n        }\n      }\n      return this.telegram.sendMessage(chatId, '≡ƒÄ¼ Highlights unavailable. Try again later.');\n    } catch (err) {\n      logger.error('Highlights error', err);\n      return this.telegram.sendMessage(chatId, 'Γ¥î Unable to fetch highlights.');\n    }\n  }\n\n  // ===== LEAGUE SUMMARY =====\n  async league(chatId, leagueName) {\n    if (!leagueName) {\n      return this.telegram.sendMessage(chatId, `Usage: /league [league name]\\nExample: /league Premier League`);\n    }\n\n    try {\n      if (this.freeSports) {\n        const guess = await this.freeSports.searchWiki(leagueName);\n        if (guess) {\n          const summary = await this.freeSports.getLeagueSummary(guess);\n          if (summary) {\n            const text = `≡ƒôÿ <b>${summary.title}</b>\\n\\n${summary.extract.substring(0, 800)}\\n\\nRead more: ${summary.url}`;\n            return this.telegram.sendMessage(chatId, text);\n          }\n        }\n      }\n\n      const msg = await this.gemini.chat(`Provide a short summary for the league: ${leagueName}`, {});\n      return this.telegram.sendMessage(chatId, `≡ƒôÿ <b>${leagueName}</b>\\n\\n${msg}`);\n    } catch (err) {\n      logger.error('League error', err);\n      return this.telegram.sendMessage(chatId, `Γ¥î Unable to fetch league info right now.`);\n    }\n  }\n\n  // ===== SIMPLE PREDICT =====\n  async predict(chatId, query) {\n    if (!query) {\n      return this.telegram.sendMessage(chatId, `Usage: /predict Home vs Away [oddsHome] \\nExample: /predict Arsenal vs Liverpool 1.95`);\n    }\n\n    try {\n      // Parse 'Team A vs Team B [odds]'\n      const parts = query.split(/vs|v/gi).map(s => s.trim());\n      if (parts.length < 2) return this.telegram.sendMessage(chatId, `Please use format: Home vs Away`);\n      const home = parts[0].replace(/\\s+$/,'');\n      const awayAndOdds = parts[1].split(/\\s+/).filter(Boolean);\n      const away = awayAndOdds[0];\n      const maybeOdds = awayAndOdds[1] ? Number(awayAndOdds[1]) : null;\n\n      // Try to get standings-derived points per game\n      let homePtsPerGame = null; let awayPtsPerGame = null;\n      if (this.freeSports) {\n        const hTitle = await this.freeSports.searchWiki(home);\n        const aTitle = await this.freeSports.searchWiki(away);\n        if (hTitle) {\n          const hStand = await this.freeSports.getStandings(hTitle, 40);\n          if (hStand) {\n            const found = hStand.find(r => (r.team || r.raw?.[1] || '').toLowerCase().includes(home.toLowerCase()));\n            if (found && found.played && found.points) {\n              homePtsPerGame = Number(found.points) / Math.max(1, Number(found.played));\n            }\n          }\n        }\n        if (aTitle) {\n          const aStand = await this.freeSports.getStandings(aTitle, 40);\n          if (aStand) {\n            const found = aStand.find(r => (r.team || r.raw?.[1] || '').toLowerCase().includes(away.toLowerCase()));\n            if (found && found.played && found.points) {\n              awayPtsPerGame = Number(found.points) / Math.max(1, Number(found.played));\n            }\n          }\n        }\n      }\n\n      const analytics = await import('./services/analytics.js');\n      const pred = await analytics.predictMatch({ home, away, homeOdds: maybeOdds, homePtsPerGame, awayPtsPerGame });\n      if (!pred) return this.telegram.sendMessage(chatId, `Γ¥î Unable to produce prediction right now.`);\n\n      const text = `≡ƒö« <b>Prediction</b>\\n${pred.home} vs ${pred.away}\\nModel P(Home): ${pred.modelProbHome}\\n` +\n        (pred.impliedHome ? `Implied P(Home): ${pred.impliedHome}\\nEdge: ${pred.edge}\\n` : '') +\n        `Kelly: ${pred.kellyFraction}\\nRecommendation: ${pred.recommended}`;\n\n      return this.telegram.sendMessage(chatId, text);\n    } catch (err) {\n      logger.error('Predict error', err);\n      return this.telegram.sendMessage(chatId, `Γ¥î Prediction failed. Try again later.`);\n    }\n  }\n\n  // ===== TIPS & STRATEGY =====\n\n  async tips(chatId) {\n    const tip = pickRandom(STRATEGY_TIPS);\n    const aiTip = await this.gemini.chat(\n      `Expand this tip into 2-3 lines: \"${tip}\". Make it actionable.`,\n      {}\n    );\n\n    const text = `${ICONS.tips} <b>Smart Betting Tips</b>\\n\\n${aiTip}\\n\\n≡ƒÆí Process over luck. Every day.`;\n    return this.telegram.sendMessage(chatId, text);\n  }\n\n  // ===== PRICING & ACCOUNT =====\n\n  async pricing(chatId) {\n    const text =\n      `${ICONS.pricing} <b>BETRIX Pricing</b>\\n\\n` +\n      `≡ƒô¥ <b>Member Signup</b>\\n` +\n      `KES ${CONFIG.PRICING.SIGNUP_FEE.KES} / USD ${CONFIG.PRICING.SIGNUP_FEE.USD}\\n` +\n      `Γ£ô Member-only features\\n\\n` +\n      `${ICONS.vvip} <b>VVIP Tiers</b>\\n` +\n      `≡ƒÆÄ Daily: KES ${CONFIG.PRICING.VVIP.DAILY.KES} / USD ${CONFIG.PRICING.VVIP.DAILY.USD}\\n` +\n      `≡ƒÆÄ Weekly: KES ${CONFIG.PRICING.VVIP.WEEKLY.KES} / USD ${CONFIG.PRICING.VVIP.WEEKLY.USD}\\n` +\n      `≡ƒÆÄ Monthly: KES ${CONFIG.PRICING.VVIP.MONTHLY.KES} / USD ${CONFIG.PRICING.VVIP.MONTHLY.USD}\\n\\n` +\n      `Γ£ô Live analysis\\nΓ£ô AI predictions\\nΓ£ô Expert odds\\nΓ£ô Priority support`;\n\n    const kb = {\n      inline_keyboard: [\n        [{ text: \"≡ƒÆ│ Get VVIP\", callback_data: \"CMD:subscribe\" }],\n        [{ text: \"≡ƒô¥ Become Member\", callback_data: \"CMD:signup\" }],\n      ],\n    };\n\n    return this.telegram.sendMessage(chatId, text, { reply_markup: kb });\n  }\n\n  async status(chatId, userId) {\n    const user = await this.userService.getUser(userId);\n\n    if (!user?.signupComplete) {\n      return this.telegram.sendMessage(chatId, `Not a member yet. Use /signup to join BETRIX.`);\n    }\n\n    const isVVIP = this.userService.isVVIP(user);\n    const text =\n      `${ICONS.status} <b>Your Account</b>\\n\\n` +\n      `≡ƒæñ Name: ${escapeHtml(user.name || \"N/A\")}\\n` +\n      `≡ƒîì Country: ${escapeHtml(user.country || \"N/A\")}\\n` +\n      `≡ƒôè Role: ${user.role === \"vvip\" ? \"≡ƒÆÄ VVIP\" : \"≡ƒæñ Member\"}\\n` +\n      `${isVVIP ? `ΓÅ░ Expires: ${new Date(user.vvip_expires_at).toLocaleDateString()}\\n` : \"\"}` +\n      `${user.referral_code ? `≡ƒæÑ Referral: ${user.referral_code}\\n` : \"\"}` +\n      `≡ƒÅå Points: ${user.rewards_points || 0}`;\n\n    return this.telegram.sendMessage(chatId, text);\n  }\n\n  // ===== REFERRALS & REWARDS =====\n\n  async refer(chatId, userId) {\n    const code = await this.userService.getOrCreateReferralCode(userId);\n    const text =\n      `${ICONS.refer} <b>Earn Rewards</b>\\n\\n` +\n      `Share your code: <code>${escapeHtml(code)}</code>\\n\\n` +\n      `≡ƒÆ░ +10 points per referral\\n` +\n      `≡ƒÄü Get 50 points = 1 month free VVIP\\n\\n` +\n      `Use: /refer [send code to friends]`;\n\n    return this.telegram.sendMessage(chatId, text);\n  }\n\n  async leaderboard(chatId) {\n    try {\n      const leaders = await this.userService.getLeaderboard(\"referrals\", 5);\n\n      if (!leaders.length) {\n        return this.telegram.sendMessage(\n          chatId,\n          `${ICONS.leaderboard} <b>Top Referrers</b>\\n\\nLeaderboard loading... Share your code to start earning!`\n        );\n      }\n\n      const text =\n        `${ICONS.leaderboard} <b>Top Referrers</b>\\n\\n` +\n        leaders.map((u, i) => `${i + 1}. ${escapeHtml(u.name)} ΓÇö ${u.score} pts`).join(\"\\n\") +\n        `\\n\\n${ICONS.refer} Use /refer to climb!`;\n\n      return this.telegram.sendMessage(chatId, text);\n    } catch (err) {\n      logger.error(\"Leaderboard error\", err);\n      return this.telegram.sendMessage(chatId, `Unable to load leaderboard. Try again later.`);\n    }\n  }\n\n  // ===== HELP & INFO =====\n\n  async help(chatId) {\n    const text =\n      `${ICONS.help} <b>BETRIX Commands</b>\\n\\n` +\n      `${ICONS.live} /live - Live matches\\n` +\n      `${ICONS.standings} /standings - League tables\\n` +\n      `${ICONS.odds} /odds [id] - Betting odds\\n` +\n      `${ICONS.analysis} /analyze [match] - AI analysis\\n` +\n      `${ICONS.tips} /tips - Strategy tips\\n` +\n      `${ICONS.pricing} /pricing - Plans\\n` +\n      `${ICONS.status} /status - Account\\n` +\n      `${ICONS.refer} /refer - Earn rewards\\n` +\n      `${ICONS.leaderboard} /leaderboard - Top earners\\n\\n` +\n      `≡ƒÆ¼ Or just chat with me naturally!`;\n\n    return this.telegram.sendMessage(chatId, text);\n  }\n\n  async about(chatId) {\n    const text =\n      `${ICONS.about} <b>About BETRIX</b>\\n\\n` +\n      `Global multi-sport AI platform.\\n` +\n      `Neutral analysis. Data-driven insights.\\n\\n` +\n      `≡ƒôè 12+ sports\\n≡ƒÆÄ AI-powered\\n≡ƒîì Global coverage\\n` +\n      `≡ƒæÑ Community rewards\\n\\n` +\n      `${pickRandom(MEMES)}`;\n\n    return this.telegram.sendMessage(chatId, text);\n  }\n\n  // ===== SIGNUP & ACCOUNT CREATION =====\n\n  async signup(chatId, userId) {\n    const user = await this.userService.getUser(userId);\n\n    if (user?.signupComplete) {\n      return this.telegram.sendMessage(chatId, `You're already a member! Use /status to view your account.`);\n    }\n\n    const text =\n      `${ICONS.signup} <b>Welcome to BETRIX</b>\\n\\n` +\n      `Quick setup (2 minutes):\\n\\n` +\n      `1∩╕ÅΓâú Your first name?\\n2∩╕ÅΓâú Your country?\\n3∩╕ÅΓâú Payment method\\n\\n` +\n      `Type your first name to begin:`;\n\n    await this.telegram.sendMessage(chatId, text);\n    await this.redis.set(`signup:${userId}:state`, \"name\", \"EX\", 300);\n  }\n\n  // ===== NATURAL LANGUAGE FALLBACK =====\n\n  async chat(chatId, userId, message) {\n    const user = await this.userService.getUser(userId);\n    const context = user || {};\n\n    try {\n      const response = await this.gemini.chat(message, context);\n      return this.telegram.sendMessage(chatId, response);\n    } catch (err) {\n      logger.error(\"Chat error\", err);\n      const fallback = this.gemini.fallbackResponse(message, context);\n      return this.telegram.sendMessage(chatId, fallback);\n    }\n  }\n}\n\nexport { BotHandlers };\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\lib\\ai.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\lib\\betrix-ingest.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\lib\\config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\lib\\lipana-client.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\lib\\local-payments.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\lib\\logger.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\lib\\redis-factory.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\lib\\redis.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\middleware\\context-manager.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\middleware\\mpesa-callback.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'subscriptions' is defined but never used.","line":8,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":33},{"ruleId":"no-unused-vars","severity":2,"message":"'phone' is assigned a value but never used.","line":34,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":34,"endColumn":18}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * M-Pesa Callback Handler\n * Handles payment verification from Safaricom\n */\n\nimport { Logger } from \"../utils/logger.js\";\nimport { db } from \"../database/db.js\";\nimport { payments, subscriptions, users } from \"../database/schema.js\";\nimport { eq } from \"drizzle-orm\";\n\nconst logger = new Logger(\"MpesaCallback\");\n\nclass MpesaCallbackHandler {\n  constructor(telegram) {\n    this.telegram = telegram;\n  }\n\n  /**\n   * Handle payment notification from M-Pesa\n   */\n  async handleCallback(req, res) {\n    try {\n      const { Body } = req.body;\n      const stkCallback = Body.stkCallback;\n\n      if (stkCallback.ResultCode !== 0) {\n        logger.warn(\"STK payment failed\", stkCallback.ResultDesc);\n        return res.status(200).json({ ResultCode: 0, ResultDesc: \"Received\" });\n      }\n\n      const callbackData = stkCallback.CallbackMetadata.Item;\n      const amount = this.extractValue(callbackData, 1);\n      const code = this.extractValue(callbackData, 2);\n      const phone = this.extractValue(callbackData, 4);\n\n      // Find payment by reference code\n      const payment = await db.query.payments.findFirst({\n        where: eq(payments.reference, code),\n      });\n\n      if (!payment) {\n        logger.warn(`Payment not found for code: ${code}`);\n        return res.status(200).json({ ResultCode: 0, ResultDesc: \"Received\" });\n      }\n\n      // Verify amount\n      if (Number(payment.amount) !== Number(amount)) {\n        logger.error(`Amount mismatch: ${payment.amount} vs ${amount}`);\n        return res.status(200).json({ ResultCode: 0, ResultDesc: \"Received\" });\n      }\n\n      // Update payment to confirmed\n      await db\n        .update(payments)\n        .set({ status: \"confirmed\", transactionId: code, verifiedAt: new Date() })\n        .where(eq(payments.id, payment.id));\n\n      // Update user tier\n      const user = await db.query.users.findFirst({\n        where: eq(users.id, payment.userId),\n      });\n\n      if (user) {\n        const tierUpdateData = {};\n\n        if (payment.tier === \"member\") {\n          tierUpdateData.tier = \"member\";\n        } else if (payment.tier?.startsWith(\"vvip\")) {\n          tierUpdateData.tier = \"vvip\";\n\n          // Calculate expiry\n          const now = new Date();\n          if (payment.tier === \"vvip_day\") {\n            tierUpdateData.vvipExpiresAt = new Date(now.getTime() + 24 * 60 * 60 * 1000);\n          } else if (payment.tier === \"vvip_week\") {\n            tierUpdateData.vvipExpiresAt = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);\n          } else if (payment.tier === \"vvip_month\") {\n            tierUpdateData.vvipExpiresAt = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);\n          }\n        }\n\n        await db.update(users).set(tierUpdateData).where(eq(users.id, user.id));\n\n        // Send confirmation to user\n        const tierName =\n          payment.tier === \"member\" ? \"Member\" : \"VVIP\";\n        await this.telegram?.sendMessage(\n          user.chatId,\n          `Γ£à Payment confirmed!\\n≡ƒÆÄ ${tierName} tier activated\\n\\nYou now have access to premium features!`\n        );\n\n        logger.info(`Payment verified: user ${user.id} - ${payment.tier}`);\n      }\n\n      return res.status(200).json({ ResultCode: 0, ResultDesc: \"Received\" });\n    } catch (err) {\n      logger.error(\"Callback processing failed\", err);\n      return res.status(200).json({ ResultCode: 0, ResultDesc: \"Received\" });\n    }\n  }\n\n  /**\n   * Extract value from M-Pesa callback metadata\n   */\n  extractValue(items, itemIndex) {\n    const item = items.find((i) => i.Name.includes(itemIndex));\n    return item?.Value || null;\n  }\n}\n\nexport { MpesaCallbackHandler };\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\middleware\\rate-limiter.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\middleware\\subscription-gatekeeper.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'logger' is assigned a value but never used.","line":9,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":13},{"ruleId":"no-unused-vars","severity":2,"message":"'action' is defined but never used.","line":138,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":138,"endColumn":38}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Subscription Gatekeeper\n * Controls feature access based on user tier\n */\n\nimport { Logger } from \"../utils/logger.js\";\nimport { UIBuilder, EMOJIS } from \"../utils/ui-builder.js\";\n\nconst logger = new Logger(\"SubscriptionGatekeeper\");\n\nclass SubscriptionGatekeeper {\n  constructor(userService, telegram) {\n    this.userService = userService;\n    this.telegram = telegram;\n  }\n\n  /**\n   * Get user tier with fallback\n   */\n  async getUserTier(userId) {\n    try {\n      const user = await this.userService.getUser(userId);\n      if (!user?.signupComplete) return \"free\";\n      if (this.userService.isVVIP(user)) return \"vvip\";\n      if (this.userService.isPaid(user)) return \"member\";\n      return \"free\";\n    } catch {\n      return \"free\";\n    }\n  }\n\n  /**\n   * Check if user can access feature\n   */\n  async canAccess(userId, feature) {\n    const tier = await this.getUserTier(userId);\n    const requirements = {\n      // Free features\n      live: \"free\",\n      standings: \"free\",\n      odds: \"free\",\n      tips: \"free\",\n      help: \"free\",\n      pricing: \"free\",\n      refer: \"free\",\n      \n      // Member features\n      analysis: \"member\",\n      predictions: \"member\",\n      stats: \"member\",\n      insights: \"member\",\n      compete: \"member\",\n      watch: \"member\",\n      \n      // VVIP features\n      dossier: \"vvip\",\n      coach: \"vvip\",\n      trends: \"vvip\",\n      premium: \"vvip\",\n      alerts: \"vvip\",\n      live_commentary: \"vvip\",\n      advanced_metrics: \"vvip\",\n    };\n\n    const required = requirements[feature] || \"free\";\n    const tierLevels = { free: 0, member: 1, vvip: 2 };\n    return tierLevels[tier] >= tierLevels[required];\n  }\n\n  /**\n   * Enforce access or show upsell\n   */\n  async enforceAccess(chatId, userId, feature) {\n    const hasAccess = await this.canAccess(userId, feature);\n\n    if (!hasAccess) {\n      const tier = await this.getUserTier(userId);\n      const requirement = this.getFeatureRequirement(feature);\n\n      let message = `${EMOJIS.locked} <b>Premium Feature</b>\\n\\n`;\n      message += `This feature requires ${requirement} membership.\\n\\n`;\n\n      if (tier === \"free\") {\n        message += `≡ƒÆí <b>Available Plans:</b>\\n`;\n        message += `≡ƒæñ Member: KES 150 / USD 1\\n`;\n        message += `≡ƒÆÄ VVIP: KES 200/day ΓÇó KES 800/week ΓÇó KES 2,500/month`;\n      } else if (tier === \"member\") {\n        message += `≡ƒÆí Upgrade to VVIP for premium analysis and live alerts`;\n      }\n\n      const kb = UIBuilder.buildSubscriptionMenu();\n      await this.telegram.sendMessage(chatId, message, { reply_markup: kb });\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Get feature requirement\n   */\n  getFeatureRequirement(feature) {\n    const map = {\n      analysis: \"Member\",\n      predictions: \"Member\",\n      dossier: \"VVIP\",\n      coach: \"VVIP\",\n      premium: \"VVIP\",\n    };\n    return map[feature] || \"Member\";\n  }\n\n  /**\n   * Decorate response based on tier\n   */\n  async decorateResponse(chatId, userId, feature, baseResponse) {\n    const tier = await this.getUserTier(userId);\n    let response = baseResponse;\n\n    // Add tier indicator\n    if (tier === \"vvip\") {\n      response += `\\n\\n≡ƒÆÄ <i>Premium content ΓÇó VVIP exclusive</i>`;\n    } else if (tier === \"member\" && [\"analysis\", \"predictions\"].includes(feature)) {\n      response += `\\n\\n≡ƒæñ <i>Member content</i>`;\n    }\n\n    // Add upsell for free users\n    if (tier === \"free\" && feature !== \"live\" && feature !== \"standings\" && feature !== \"odds\") {\n      response += `\\n\\n≡ƒÆí <i>Upgrade to unlock full analysis</i>`;\n    }\n\n    return response;\n  }\n\n  /**\n   * Check rate limits by tier\n   */\n  async checkRateLimit(userId, action) {\n    const tier = await this.getUserTier(userId);\n    const limits = {\n      free: 30,     // 30 requests per minute\n      member: 100,  // 100 requests per minute\n      vvip: 500,    // 500 requests per minute\n    };\n\n    return limits[tier] || 30;\n  }\n\n  /**\n   * Get feature description by tier\n   */\n  getFeatureDescription(feature, tier) {\n    const descriptions = {\n      analysis: {\n        free: \"≡ƒöÆ Match analysis available for members\",\n        member: \"Match analysis with key statistics\",\n        vvip: \"≡ƒöÑ Advanced match analysis with tactical breakdown\",\n      },\n      predictions: {\n        free: \"≡ƒöÆ Predictions available for members\",\n        member: \"AI predictions with confidence scoring\",\n        vvip: \"≡ƒöÑ Elite predictions with expected value analysis\",\n      },\n      dossier: {\n        free: \"≡ƒöÆ Professional dossier for VVIP\",\n        member: \"≡ƒöÆ Professional dossier for VVIP\",\n        vvip: \"≡ƒôï 500+ word professional match analysis\",\n      },\n      coach: {\n        free: \"≡ƒöÆ Coaching available for VVIP\",\n        member: \"≡ƒöÆ Coaching available for VVIP\",\n        vvip: \"≡ƒÅå Personal betting strategy coaching\",\n      },\n    };\n\n    return (descriptions[feature]?.[tier] || \"Feature unavailable\").trim();\n  }\n\n  /**\n   * Log feature access for analytics\n   */\n  async logAccess(userId, feature, allowed) {\n    try {\n      const tier = await this.getUserTier(userId);\n      const key = `access:${feature}:${tier}`;\n      const field = allowed ? \"allowed\" : \"blocked\";\n      await this.redis?.hincrby(key, field, 1);\n    } catch {\n      // Ignore errors\n    }\n  }\n}\n\nexport { SubscriptionGatekeeper };\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\middleware\\validation.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'logger' is assigned a value but never used.","line":8,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":13},{"ruleId":"no-unused-vars","severity":2,"message":"'country' is assigned a value but never used.","line":14,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":38},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\+.","line":16,"column":25,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":16,"endColumn":26,"suggestions":[{"messageId":"removeEscape","fix":{"range":[323,324],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[323,323],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\\".","line":61,"column":20,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":61,"endColumn":21,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1328,1329],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1328,1328],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\+.","line":71,"column":44,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":71,"endColumn":45,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1564,1565],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1564,1564],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Input Validation Middleware\n */\n\nimport Joi from \"joi\";\nimport { Logger } from \"../utils/logger.js\";\n\nconst logger = new Logger(\"Validation\");\n\nclass ValidationMiddleware {\n  /**\n   * Validate phone number\n   */\n  static validatePhone(phone, country = \"KE\") {\n    const schema = Joi.string()\n      .pattern(/^[\\d\\s\\-\\+]+$/)\n      .min(10)\n      .max(15)\n      .required();\n\n    const { error, value } = schema.validate(phone);\n    return { valid: !error, value, error: error?.message };\n  }\n\n  /**\n   * Validate email\n   */\n  static validateEmail(email) {\n    const schema = Joi.string().email().required();\n    const { error, value } = schema.validate(email);\n    return { valid: !error, value, error: error?.message };\n  }\n\n  /**\n   * Validate command input\n   */\n  static validateCommandInput(input) {\n    // Prevent common injection patterns\n    const blockedPatterns = [\n      /DROP|DELETE|INSERT|UPDATE|EXEC/i,\n      /<script|javascript:/i,\n      /union.*select/i,\n      /1=1/i,\n    ];\n\n    for (const pattern of blockedPatterns) {\n      if (pattern.test(input)) {\n        return { valid: false, error: \"Invalid input detected\" };\n      }\n    }\n\n    return { valid: true, value: input };\n  }\n\n  /**\n   * Sanitize user input\n   */\n  static sanitize(input) {\n    return String(input)\n      .trim()\n      .replace(/[<>\\\"']/g, \"\")\n      .slice(0, 500); // Max 500 chars\n  }\n\n  /**\n   * Validate user data\n   */\n  static validateUserData(data) {\n    const schema = Joi.object({\n      name: Joi.string().max(100),\n      phone: Joi.string().pattern(/^[\\d\\s\\-\\+]+$/),\n      country: Joi.string().length(2),\n      email: Joi.string().email(),\n    });\n\n    return schema.validate(data, { abortEarly: false });\n  }\n\n  /**\n   * Validate payment data\n   */\n  static validatePaymentData(data) {\n    const schema = Joi.object({\n      amount: Joi.number().positive().required(),\n      method: Joi.string()\n        .valid(\"till\", \"paypal\", \"binance\", \"bank\", \"stk\")\n        .required(),\n      tier: Joi.string().valid(\"member\", \"vvip_day\", \"vvip_week\", \"vvip_month\"),\n      reference: Joi.string().max(100),\n    });\n\n    return schema.validate(data);\n  }\n}\n\nexport { ValidationMiddleware };\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\middleware\\webhook-handler.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\routes\\admin.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'os' is defined but never used.","line":4,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":10}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from 'express';\r\nimport fs from 'fs';\r\nimport path from 'path';\r\nimport os from 'os';\r\n\r\nexport default function createAdminRouter() {\r\n  const router = express.Router();\r\n\r\n  router.get('/health', (_req, res) => res.json({ ok: true, commit: process.env.RENDER_GIT_COMMIT || process.env.COMMIT_SHA || null }));\r\n\r\n  router.get('/queue', (_req, res) => res.json({ ok: true, commit: process.env.RENDER_GIT_COMMIT || process.env.COMMIT_SHA || null }));\r\n\r\n  router.get('/redis-ping', async (req, res) => {\r\n    try {\r\n      const client = req.app && req.app.locals && req.app.locals.redis;\r\n      if (!client) return res.status(500).json({ status: 'no redis client' });\r\n      const pong = await client.ping();\r\n      return res.json({ status: 'ok', pong });\r\n    } catch (err) {\r\n      return res.status(500).json({ status: 'error', message: err?.message || String(err) });\r\n    }\r\n  });\r\n\r\n  router.get('/webhook-fallback', (_req, res) => {\r\n    try {\r\n      const logPath = path.join(process.cwd(), 'webhooks.log');\r\n      if (!fs.existsSync(logPath)) return res.json({ ok: true, entries: [] });\r\n      const txt = fs.readFileSync(logPath, 'utf8');\r\n      const lines = txt.split(/\\r?\\n/).filter(Boolean).slice(-200);\r\n      const parsed = lines.map(l => { try { return JSON.parse(l); } catch { return { raw: l }; } });\r\n      return res.json({ ok: true, entries: parsed });\r\n    } catch (e) {\r\n      return res.status(500).json({ ok: false, error: e?.message || String(e) });\r\n    }\r\n  });\r\n\r\n  // Expose recent unmatched requests captured by app's final 404 logger\r\n  router.get('/debug-404', (_req, res) => {\r\n    try {\r\n      const logPath = path.join(process.cwd(), 'debug_404.log');\r\n      if (!fs.existsSync(logPath)) return res.json({ ok: true, entries: [] });\r\n      const txt = fs.readFileSync(logPath, 'utf8');\r\n      const lines = txt.split(/\\r?\\n/).filter(Boolean).slice(-200);\r\n      return res.json({ ok: true, entries: lines });\r\n    } catch (e) {\r\n      return res.status(500).json({ ok: false, error: e?.message || String(e) });\r\n    }\r\n  });\r\n\r\n  // Process info for debugging which entrypoint is running on the host\r\n  router.get('/process-info', (_req, res) => {\r\n    try {\r\n      const info = {\r\n        pid: process.pid,\r\n        argv: process.argv,\r\n        nodeVersion: process.version,\r\n        uptimeSeconds: Math.floor(process.uptime()),\r\n        env: {\r\n          PORT: process.env.PORT || null,\r\n          START_HTTP_IN_WORKER: process.env.START_HTTP_IN_WORKER || null,\r\n          NODE_ENV: process.env.NODE_ENV || null\r\n        }\r\n      };\r\n      return res.json({ ok: true, info });\r\n    } catch (e) {\r\n      return res.status(500).json({ ok: false, error: e?.message || String(e) });\r\n    }\r\n  });\r\n\r\n  // Diagnostic: list registered routes on the app\r\n  router.get('/routes', (_req, res) => {\r\n    try {\r\n      const app = _req.app || _req.router && _req.router.app;\r\n      const routes = [];\r\n      const stack = (app && app._router && app._router.stack) || [];\r\n      stack.forEach((layer) => {\r\n        try {\r\n          if (layer.route) {\r\n            routes.push({ path: layer.route.path, methods: Object.keys(layer.route.methods) });\r\n          } else if (layer.name === 'router' && layer.handle && layer.handle.stack) {\r\n            // find mount path if present\r\n            const mountPath = layer.regexp && layer.regexp.fast_slash ? '' : (layer.regexp && layer.regexp.source) || '';\r\n            layer.handle.stack.forEach((l) => {\r\n              if (l.route) routes.push({ path: (mountPath || '') + l.route.path, methods: Object.keys(l.route.methods) });\r\n            });\r\n          }\r\n        } catch (e) { /* ignore per-layer errors */ }\r\n      });\r\n      return res.json({ ok: true, routes });\r\n    } catch (e) {\r\n      return res.status(500).json({ ok: false, error: e?.message || String(e) });\r\n    }\r\n  });\r\n\r\n  return router;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\routes\\webhooks.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\runtime-env-check.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\scripts\\enqueue-test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\server.js","messages":[{"ruleId":"import/no-named-as-default","severity":1,"message":"Using exported name 'rateLimit' as identifier for default import.","line":9,"column":8,"nodeType":"ImportDefaultSpecifier","endLine":9,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * BETRIX Express Server\n * HTTP API + Telegram Webhook + Admin Dashboard\n */\n\nimport express from \"express\";\nimport helmet from \"helmet\";\nimport cors from \"cors\";\nimport rateLimit from \"express-rate-limit\";\nimport { Logger } from \"./utils/logger.js\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport crypto from \"crypto\";\nimport { betrixIngest } from \"./lib/betrix-ingest.js\";\nimport { MpesaCallbackHandler } from \"./middleware/mpesa-callback.js\";\nimport { updateStatusByProviderEventId } from './lib/local-payments.js';\n\nconst logger = new Logger(\"Server\");\nconst app = express();\n\n// Middleware\napp.use(helmet());\napp.use(cors());\n// capture raw body for signature verification while still parsing JSON\napp.use(express.json({ limit: \"10mb\", verify: (req, res, buf) => { req.rawBody = buf; } }));\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100,\n});\napp.use(limiter);\n\n// Health check\napp.get(\"/health\", (req, res) => {\n  res.json({ status: \"ok\", timestamp: new Date(), service: \"BETRIX\" });\n});\n\n// Telegram webhook\napp.post(\"/webhook/telegram\", async (req, res) => {\n  try {\n    res.status(200).json({ ok: true });\n  } catch (err) {\n    logger.error(\"Webhook error\", err);\n    res.status(500).json({ ok: false });\n  }\n});\n\n// M-Pesa callback\napp.post(\"/webhook/mpesa\", async (req, res) => {\n  try {\n    // Prefer Lipana signature header (case-insensitive)\n    const signatureHeader = req.headers['x-lipana-signature'] || req.headers['x-signature'] || req.headers['x-lipana-hmac'] || '';\n    const secret = process.env.LIPANA_SECRET;\n\n    if (!secret) {\n      logger.error('LIPANA_SECRET not configured');\n      return res.status(500).json({ ok: false, error: 'server misconfigured' });\n    }\n\n    const raw = req.rawBody || Buffer.from(JSON.stringify(req.body || {}));\n    const computed = crypto.createHmac('sha256', secret).update(raw).digest('hex');\n\n    // Use timingSafeEqual to avoid timing attacks\n    const valid = signatureHeader && (() => {\n      try {\n        return crypto.timingSafeEqual(Buffer.from(computed), Buffer.from(signatureHeader));\n      } catch (e) { return false; }\n    })();\n\n    if (!valid) {\n      const logDir = path.join(process.cwd(), 'logs');\n      const logPath = path.join(logDir, 'webhook.log');\n      const logEntry = `${new Date().toISOString()} INVALID signature=${signatureHeader} computed=${computed}\\n`;\n      try { if (!fs.existsSync(logDir)) fs.mkdirSync(logDir, { recursive: true }); fs.appendFileSync(logPath, logEntry); } catch (e){ logger.error('log write failed', e); }\n      logger.warn('Invalid Lipana signature');\n      return res.status(401).send('Invalid signature');\n    }\n\n    // Verified\n    const payloadText = raw.toString('utf8');\n    let payload = {};\n    try { payload = JSON.parse(payloadText); } catch (e) { payload = req.body || {}; }\n\n    const logDir = path.join(process.cwd(), 'logs');\n    const logPath = path.join(logDir, 'webhook.log');\n    const logEntry = `${new Date().toISOString()} VERIFIED event=${payload.event || 'unknown'} payload=${payloadText}\\n`;\n    try { if (!fs.existsSync(logDir)) fs.mkdirSync(logDir, { recursive: true }); fs.appendFileSync(logPath, logEntry); } catch (e){ logger.error('log write failed', e); }\n\n    // Hand off to ingestion adapter (persist or queue)\n    try {\n      await betrixIngest(payload);\n    } catch (err) {\n      logger.error('Ingest failed', err);\n      // continue; we still return 200 to the provider to avoid retries\n    }\n\n    // If this webhook refers to a local pending payment, update it (simulation-friendly)\n    try {\n      const providerEventId = payload && payload.data && (payload.data.id || payload.data.transaction_id) ;\n      if (providerEventId) {\n        const updated = updateStatusByProviderEventId(providerEventId, 'success', { provider: 'lipana' });\n        if (updated) logger.info('Local payment updated from webhook', updated.id || updated.tx_ref);\n      }\n    } catch (e) { logger.error('Local payment update failed', e); }\n\n    // Also call the existing Mpesa handler if this looks like a Daraja/Daraja STK body\n    try {\n      if (req.body && req.body.Body && req.body.Body.stkCallback) {\n        const handler = new MpesaCallbackHandler();\n        await handler.handleCallback(req, res);\n        return; // handler will have responded\n      }\n    } catch (err) {\n      // If the Mpesa handler throws, we've already ingested; log and respond OK\n      logger.info('MpesaCallbackHandler did not complete, but webhook verified and ingested', err);\n      return res.status(200).json({ ok: true });\n    }\n\n    // Default OK response for non-Daraja webhooks\n    return res.status(200).json({ ResultCode: 0, ResultDesc: 'Received' });\n\n  } catch (err) {\n    logger.error(\"M-Pesa webhook error\", err);\n    res.status(500).json({ ok: false });\n  }\n});\n\n// Start server\nexport function startServer() {\n  const PORT = process.env.PORT ? Number(process.env.PORT) : 5000;\n  const server = app.listen(PORT, \"0.0.0.0\", () => {\n    logger.info(`≡ƒÜÇ Server on port ${PORT}`);\n  });\n\n  process.on(\"SIGTERM\", () => {\n    logger.info(\"Shutting down...\");\n    server.close(() => process.exit(0));\n  });\n\n  return server;\n}\n\nexport { app };\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\server.orig.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":1,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":1,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":7,"column":39,"nodeType":"Identifier","messageId":"undef","endLine":7,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":7,"column":46,"nodeType":"Identifier","messageId":"undef","endLine":7,"endColumn":49},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":7,"column":57,"nodeType":"Identifier","messageId":"undef","endLine":7,"endColumn":60},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":9,"column":39,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":9,"column":46,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":49},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":9,"column":57,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":60},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":11,"column":39,"nodeType":"Identifier","messageId":"undef","endLine":11,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":11,"column":46,"nodeType":"Identifier","messageId":"undef","endLine":11,"endColumn":49},{"ruleId":"no-undef","severity":2,"message":"'app' is not defined.","line":11,"column":57,"nodeType":"Identifier","messageId":"undef","endLine":11,"endColumn":60}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"∩╗┐try { app.use(require('./server/telegram-fixed')); console.log('MOUNTED: ./server/telegram-fixed'); } catch(e) { console.error('MOUNT_FAILED_FIXED', e && e.stack ? e.stack : String(e)); }\n\ntry {\n  // Ensure telegram router is mounted so POST /telegram is registered\n  const _tg = require('./server/telegram');\n  if (_tg && typeof _tg === 'function') {\n    if (typeof app !== 'undefined' && app && app.use) { app.use(_tg); console.log('MOUNTED: ./server/telegram (function export)'); }\n  } else if (_tg && _tg.router) {\n    if (typeof app !== 'undefined' && app && app.use) { app.use(_tg.router); console.log('MOUNTED: ./server/telegram (router export)'); }\n  } else {\n    if (typeof app !== 'undefined' && app && app.use) { app.use(_tg); console.log('MOUNTED: ./server/telegram (assumed middleware)'); }\n  }\n} catch(e){\n  console.error('MOUNT_TELEGRAM_IN_SERVER_ORIG_FAILED', e && e.stack ? e.stack : String(e));\n}\n\n\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\src\\server\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\src\\server\\telegram-webhook.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\telegram-quick-reply.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\src\\worker-final.js","messages":[],"suppressedMessages":[{"ruleId":"no-constant-condition","severity":2,"message":"Unexpected constant condition.","line":519,"column":12,"nodeType":"Literal","messageId":"unexpected","endLine":519,"endColumn":16,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-unused-vars","severity":2,"message":"'handleCallback' is defined but never used.","line":932,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":932,"endColumn":30,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-unused-vars","severity":2,"message":"'action' is assigned a value but never used.","line":933,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":933,"endColumn":16,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-unused-vars","severity":2,"message":"'params' is assigned a value but never used.","line":933,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":933,"endColumn":27,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\tests\\cache-service.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\tests\\comprehensive-integration.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\tests\\openligadb.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\tests\\payment-guides.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\tests\\payment-integration.test.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'getPaymentInstructions' is defined but never used.","line":12,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":25},{"ruleId":"no-unused-vars","severity":2,"message":"'verifyAndActivatePayment' is defined but never used.","line":13,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":27},{"ruleId":"no-unused-vars","severity":2,"message":"'err' is defined but never used.","line":52,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":52,"endColumn":33},{"ruleId":"no-unused-vars","severity":2,"message":"'tier' is assigned a value but never used.","line":68,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":68,"endColumn":13}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * payment-integration.test.js\r\n * Integration tests for payment method normalization across call sites\r\n */\r\n\r\nimport assert from 'assert';\r\n// We'll use a lightweight in-memory MockRedis for test runs when MOCK_REDIS=1\r\nimport {\r\n  normalizePaymentMethod,\r\n  createPaymentOrder,\r\n  createCustomPaymentOrder,\r\n  getPaymentInstructions,\r\n  verifyAndActivatePayment\r\n} from '../src/handlers/payment-router.js';\r\n\r\nlet redis;\r\nif (process.env.MOCK_REDIS === '1' || !process.env.REDIS_URL) {\r\n  // Simple in-memory Redis replacement for tests\r\n  class MockRedis {\r\n    constructor() { this.store = new Map(); }\r\n    async ping() { return 'PONG'; }\r\n    async setex(key, ttl, value) { this.store.set(key, value); return 'OK'; }\r\n    async set(key, value) { this.store.set(key, value); return 'OK'; }\r\n    async get(key) { return this.store.has(key) ? this.store.get(key) : null; }\r\n    async keys(pattern) {\r\n      const regex = new RegExp('^' + pattern.replace(/\\*/g, '.*') + '$');\r\n      return Array.from(this.store.keys()).filter(k => regex.test(k));\r\n    }\r\n    on() { /* noop */ }\r\n  }\r\n\r\n  console.log('ΓÜá∩╕Å  Using MockRedis for integration tests');\r\n  redis = new MockRedis();\r\n} else {\r\n  // dynamic import of ioredis only when needed\r\n  const { default: IORedis } = await import('ioredis');\r\n  redis = new IORedis({\r\n    host: process.env.REDIS_HOST || 'localhost',\r\n    port: parseInt(process.env.REDIS_PORT || '6379'),\r\n    lazyConnect: true,\r\n    maxRetriesPerRequest: 1,\r\n    reconnectOnError: () => false\r\n  });\r\n  redis.on('error', (err) => console.warn('ΓÜá∩╕Å  [ioredis] Ignoring Redis error in test:', err && err.message ? err.message : err));\r\n}\r\n\r\nconsole.log('≡ƒº¬ Payment Integration Tests\\n');\r\n\r\nasync function runTests() {\r\n  try {\r\n    // Try to connect to Redis; if it fails, use a simple mock\r\n    await redis.ping().catch(err => {\r\n      console.warn('ΓÜá∩╕Å  Redis not available; using mock for tests');\r\n      return false;\r\n    });\r\n  } catch (e) {\r\n    console.warn('ΓÜá∩╕Å  Redis connection skipped; tests will use local storage');\r\n  }\r\n\r\n  // Test 1: normalizePaymentMethod is exported and callable\r\n  console.log('≡ƒôî Test: normalizePaymentMethod is a function');\r\n  assert(typeof normalizePaymentMethod === 'function', 'normalizePaymentMethod should be a function');\r\n  console.log('Γ£à PASS\\n');\r\n\r\n  // Test 2: createPaymentOrder accepts normalized and non-normalized methods\r\n  console.log('≡ƒôî Test: createPaymentOrder accepts various method formats');\r\n  const userId = 123456;\r\n  const tier = 'VVIP';\r\n  const region = 'KE';\r\n\r\n  try {\r\n    // Test with canonical key\r\n    const order1 = await createPaymentOrder(redis, userId, 'VVIP', 'SAFARICOM_TILL', region);\r\n    assert(order1 && order1.orderId, 'Should create order with canonical key SAFARICOM_TILL');\r\n    assert(order1.paymentMethod === 'SAFARICOM_TILL', 'paymentMethod should be normalized');\r\n    console.log('Γ£à PASS: Canonical key accepted');\r\n  } catch (err) {\r\n    console.log('ΓÜá∩╕Å  SKIP (Redis): Canonical key test', err.message);\r\n  }\r\n\r\n  try {\r\n    // Test with common alias (will be normalized internally)\r\n    const order2 = await createPaymentOrder(redis, userId + 1, 'VVIP', 'till', region);\r\n    assert(order2 && order2.orderId, 'Should create order with alias \"till\"');\r\n    assert(order2.paymentMethod === 'SAFARICOM_TILL', 'Alias should be normalized to SAFARICOM_TILL');\r\n    console.log('Γ£à PASS: Common alias accepted and normalized');\r\n  } catch (err) {\r\n    if (err.message.includes('Unknown payment method')) {\r\n      console.log('Γ£à PASS: Alias normalization error caught (expected if Redis unavailable)');\r\n    } else {\r\n      console.log('ΓÜá∩╕Å  SKIP (Redis): Alias test', err.message);\r\n    }\r\n  }\r\n\r\n  try {\r\n    // Test with M-Pesa alias\r\n    const order3 = await createPaymentOrder(redis, userId + 2, 'VVIP', 'mpesa_stk', region);\r\n    assert(order3 && order3.orderId, 'Should create order with alias \"mpesa_stk\"');\r\n    assert(order3.paymentMethod === 'MPESA', 'Alias should be normalized to MPESA');\r\n    console.log('Γ£à PASS: M-Pesa STK alias accepted and normalized');\r\n  } catch (err) {\r\n    if (err.message.includes('Unknown payment method')) {\r\n      console.log('Γ£à PASS: M-Pesa alias normalization (expected if Redis unavailable)');\r\n    } else {\r\n      console.log('ΓÜá∩╕Å  SKIP: M-Pesa alias test', err.message);\r\n    }\r\n  }\r\n\r\n  console.log();\r\n\r\n  // Test 3: createCustomPaymentOrder accepts normalized methods\r\n  console.log('≡ƒôî Test: createCustomPaymentOrder accepts various method formats');\r\n  try {\r\n    const order = await createCustomPaymentOrder(redis, userId + 10, 150, 'paypal', region, { signup: true });\r\n    assert(order && order.orderId, 'Should create custom order with alias \"paypal\"');\r\n    assert(order.paymentMethod === 'PAYPAL', 'Alias should be normalized to PAYPAL');\r\n    console.log('Γ£à PASS: Alias normalized in custom order creation');\r\n  } catch (err) {\r\n    if (err.message.includes('Unknown payment method')) {\r\n      console.log('Γ£à PASS: Normalization applied (expected if Redis unavailable)');\r\n    } else {\r\n      console.log('ΓÜá∩╕Å  SKIP: Custom order test', err.message);\r\n    }\r\n  }\r\n\r\n  console.log();\r\n\r\n  // Test 4: Callback data parsing simulation\r\n  console.log('≡ƒôî Test: Callback data method extraction (simulates telegram handler)');\r\n  const callbackData = 'pay_till';\r\n  const methodFromCallback = callbackData.replace('pay_', '').toUpperCase(); // \"TILL\"\r\n  const normalized = normalizePaymentMethod(methodFromCallback);\r\n  assert(normalized === 'SAFARICOM_TILL', `\"${methodFromCallback}\" should normalize to SAFARICOM_TILL`);\r\n  console.log('Γ£à PASS: Callback method extracted and normalized correctly\\n');\r\n\r\n  // Test 5: Signup payment callback parsing\r\n  console.log('≡ƒôî Test: Signup payment callback parsing');\r\n  const signupData = 'signup_pay_mpesa_150_KES';\r\n  const signupParts = signupData.split('_');\r\n  let signupMethod = signupParts[2]; // \"mpesa\"\r\n  signupMethod = normalizePaymentMethod(signupMethod) || signupMethod;\r\n  assert(signupMethod === 'MPESA', `Signup method \"${signupParts[2]}\" should normalize to MPESA`);\r\n  console.log('Γ£à PASS: Signup callback method normalized correctly\\n');\r\n\r\n  // Test 6: Verify provider refs use normalized keys\r\n  console.log('≡ƒôî Test: Provider ref mappings use normalized keys');\r\n  const testKey = 'SAFARICOM_TILL';\r\n  const redisKey = `payment:by_provider_ref:${testKey}:TEST_REF`;\r\n  assert(\r\n    testKey === normalizePaymentMethod('till'),\r\n    'Redis key should use normalized canonical key'\r\n  );\r\n  console.log(`Γ£à PASS: Provider ref key format verified: ${redisKey}\\n`);\r\n\r\n  console.log('≡ƒÄë All integration tests passed!\\n');\r\n}\r\n\r\nrunTests().catch(err => {\r\n  console.error('Γ¥î Test suite error:', err);\r\n  process.exit(1);\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\tests\\payment-normalizer.test.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'_' is assigned a value but never used.","line":89,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":89,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * payment-normalizer.test.js\r\n * Unit tests for normalizePaymentMethod helper\r\n */\r\n\r\nimport assert from 'assert';\r\nimport { normalizePaymentMethod, PAYMENT_PROVIDERS } from '../src/handlers/payment-router.js';\r\n\r\nconsole.log('≡ƒº¬ Payment Method Normalizer Tests\\n');\r\n\r\n// Test: Direct provider keys (should pass through)\r\nconsole.log('≡ƒôî Test: Direct provider keys (uppercase)');\r\nassert(normalizePaymentMethod('MPESA') === 'MPESA', 'MPESA should normalize to MPESA');\r\nassert(normalizePaymentMethod('PAYPAL') === 'PAYPAL', 'PAYPAL should normalize to PAYPAL');\r\nassert(normalizePaymentMethod('SAFARICOM_TILL') === 'SAFARICOM_TILL', 'SAFARICOM_TILL should normalize to SAFARICOM_TILL');\r\nassert(normalizePaymentMethod('BINANCE') === 'BINANCE', 'BINANCE should normalize to BINANCE');\r\nassert(normalizePaymentMethod('SWIFT') === 'SWIFT', 'SWIFT should normalize to SWIFT');\r\nassert(normalizePaymentMethod('BITCOIN') === 'BITCOIN', 'BITCOIN should normalize to BITCOIN');\r\nconsole.log('Γ£à PASS: All direct provider keys normalize correctly\\n');\r\n\r\n// Test: Common aliases (lowercase/mixed case)\r\nconsole.log('≡ƒôî Test: Common aliases');\r\nassert(normalizePaymentMethod('mpesa') === 'MPESA', 'mpesa -> MPESA');\r\nassert(normalizePaymentMethod('paypal') === 'PAYPAL', 'paypal -> PAYPAL');\r\nassert(normalizePaymentMethod('binance') === 'BINANCE', 'binance -> BINANCE');\r\nassert(normalizePaymentMethod('swift') === 'SWIFT', 'swift -> SWIFT');\r\nassert(normalizePaymentMethod('bitcoin') === 'BITCOIN', 'bitcoin -> BITCOIN');\r\nconsole.log('Γ£à PASS: All common aliases normalize correctly\\n');\r\n\r\n// Test: Safaricom Till aliases\r\nconsole.log('≡ƒôî Test: Safaricom Till aliases');\r\nassert(normalizePaymentMethod('safaricom') === 'SAFARICOM_TILL', 'safaricom -> SAFARICOM_TILL');\r\nassert(normalizePaymentMethod('safaricom_till') === 'SAFARICOM_TILL', 'safaricom_till -> SAFARICOM_TILL');\r\nassert(normalizePaymentMethod('till') === 'SAFARICOM_TILL', 'till -> SAFARICOM_TILL');\r\nassert(normalizePaymentMethod('TILL') === 'SAFARICOM_TILL', 'TILL -> SAFARICOM_TILL');\r\nconsole.log('Γ£à PASS: All Safaricom Till aliases normalize correctly\\n');\r\n\r\n// Test: M-Pesa aliases\r\nconsole.log('≡ƒôî Test: M-Pesa aliases');\r\nassert(normalizePaymentMethod('mpesa_stk') === 'MPESA', 'mpesa_stk -> MPESA');\r\nassert(normalizePaymentMethod('stk') === 'MPESA', 'stk -> MPESA');\r\nassert(normalizePaymentMethod('MPESA_STK') === 'MPESA', 'MPESA_STK -> MPESA');\r\nconsole.log('Γ£à PASS: All M-Pesa aliases normalize correctly\\n');\r\n\r\n// Test: Binance aliases\r\nconsole.log('≡ƒôî Test: Binance aliases');\r\nassert(normalizePaymentMethod('binance_pay') === 'BINANCE', 'binance_pay -> BINANCE');\r\nassert(normalizePaymentMethod('BINANCE_PAY') === 'BINANCE', 'BINANCE_PAY -> BINANCE');\r\nconsole.log('Γ£à PASS: All Binance aliases normalize correctly\\n');\r\n\r\n// Test: Bank/Swift aliases\r\nconsole.log('≡ƒôî Test: Bank/Swift aliases');\r\nassert(normalizePaymentMethod('bank') === 'SWIFT', 'bank -> SWIFT');\r\nassert(normalizePaymentMethod('bank_transfer') === 'SWIFT', 'bank_transfer -> SWIFT');\r\nassert(normalizePaymentMethod('BANK_TRANSFER') === 'SWIFT', 'BANK_TRANSFER -> SWIFT');\r\nconsole.log('Γ£à PASS: All Bank/Swift aliases normalize correctly\\n');\r\n\r\n// Test: Bitcoin aliases\r\nconsole.log('≡ƒôî Test: Bitcoin aliases');\r\nassert(normalizePaymentMethod('btc') === 'BITCOIN', 'btc -> BITCOIN');\r\nassert(normalizePaymentMethod('BTC') === 'BITCOIN', 'BTC -> BITCOIN');\r\nassert(normalizePaymentMethod('eth') === 'BITCOIN', 'eth -> BITCOIN (maps to BITCOIN)');\r\nconsole.log('Γ£à PASS: All Bitcoin aliases normalize correctly\\n');\r\n\r\n// Test: Whitespace trimming\r\nconsole.log('≡ƒôî Test: Whitespace handling');\r\nassert(normalizePaymentMethod('  mpesa  ') === 'MPESA', 'Whitespace should be trimmed');\r\nassert(normalizePaymentMethod('\\tpaypal\\n') === 'PAYPAL', 'Tabs/newlines should be trimmed');\r\nconsole.log('Γ£à PASS: Whitespace is handled correctly\\n');\r\n\r\n// Test: Invalid inputs\r\nconsole.log('≡ƒôî Test: Invalid/unknown methods');\r\nassert(normalizePaymentMethod('unknown_method') === null, 'Unknown method should return null');\r\nassert(normalizePaymentMethod('fake_provider') === null, 'Fake provider should return null');\r\nassert(normalizePaymentMethod('') === null, 'Empty string should return null');\r\nassert(normalizePaymentMethod(null) === null, 'null input should return null');\r\nassert(normalizePaymentMethod(undefined) === null, 'undefined input should return null');\r\nconsole.log('Γ£à PASS: Invalid inputs return null\\n');\r\n\r\n// Test: Mixed case combinations\r\nconsole.log('≡ƒôî Test: Mixed case combinations');\r\nassert(normalizePaymentMethod('MpEsA') === 'MPESA', 'Mixed case MpEsA -> MPESA');\r\nassert(normalizePaymentMethod('PayPal') === 'PAYPAL', 'Mixed case PayPal -> PAYPAL');\r\nassert(normalizePaymentMethod('SaFaRiCoM_TiLl') === 'SAFARICOM_TILL', 'Mixed case SaFaRiCoM_TiLl -> SAFARICOM_TILL');\r\nconsole.log('Γ£à PASS: All mixed case inputs normalize correctly\\n');\r\n\r\n// Test: All defined providers can be normalized from lowercase\r\nconsole.log('≡ƒôî Test: All defined providers normalize from lowercase');\r\nfor (const [key, _] of Object.entries(PAYMENT_PROVIDERS)) {\r\n  const normalized = normalizePaymentMethod(key.toLowerCase());\r\n  assert(normalized === key, `${key.toLowerCase()} should normalize to ${key}, got ${normalized}`);\r\n}\r\nconsole.log('Γ£à PASS: All defined providers normalize from lowercase\\n');\r\n\r\nconsole.log('≡ƒÄë All payment normalizer tests passed!\\n');\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\tests\\payment-router.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\tests\\rss-aggregator.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\tests\\run-tests.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\tests\\telegram-bot.test.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'logger' is assigned a value but never used.","line":12,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":13},{"ruleId":"no-unused-vars","severity":2,"message":"'chatId' is defined but never used.","line":42,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":42,"endColumn":31},{"ruleId":"no-unused-vars","severity":2,"message":"'text' is defined but never used.","line":42,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":42,"endColumn":37},{"ruleId":"no-unused-vars","severity":2,"message":"'opts' is defined but never used.","line":42,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":42,"endColumn":43},{"ruleId":"no-unused-vars","severity":2,"message":"'mainMenu' is assigned a value but never used.","line":61,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":61,"endColumn":21}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n/**\r\n * BETRIX Telegram Bot - Command & Callback Test Suite\r\n * Tests all commands and menus to ensure proper functionality\r\n * \r\n * Usage: node tests/telegram-bot.test.js\r\n */\r\n\r\nimport assert from 'assert';\r\nimport { Logger } from '../src/utils/logger.js';\r\n\r\nconst logger = new Logger('BotTests');\r\n\r\n// Mock Redis client\r\nclass MockRedis {\r\n  constructor() {\r\n    this.data = {};\r\n  }\r\n\r\n  async hgetall(key) {\r\n    return this.data[key] || {};\r\n  }\r\n\r\n  async hset(key, obj) {\r\n    this.data[key] = obj;\r\n    return 1;\r\n  }\r\n\r\n  async get(key) {\r\n    return this.data[key] || null;\r\n  }\r\n\r\n  async setex(key, exp, val) {\r\n    this.data[key] = val;\r\n    return 'OK';\r\n  }\r\n}\r\n\r\n// Mock services\r\nconst mockServices = {\r\n  telegram: {\r\n    sendMessage: async (chatId, text, opts) => ({ ok: true, result: { message_id: 1 } })\r\n  },\r\n  api: {}\r\n};\r\n\r\n// ============================================================================\r\n// TEST SUITE\r\n// ============================================================================\r\n\r\nasync function runTests() {\r\n  console.log('\\n≡ƒº¬ Starting BETRIX Bot Command Tests...\\n');\r\n\r\n  const redis = new MockRedis();\r\n  const testResults = [];\r\n\r\n  try {\r\n    // Import handlers\r\n    const { handleCommand } = await import('../src/handlers/commands.js');\r\n    const { handleCallback } = await import('../src/handlers/callbacks.js');\r\n    const { mainMenu } = await import('../src/handlers/menu-system.js');\r\n\r\n    const userId = 123456;\r\n    const chatId = 789012;\r\n\r\n    // Test 1: /start command\r\n    console.log('≡ƒôî Test 1: /start command');\r\n    const startResult = await handleCommand('/start', chatId, userId, redis, mockServices);\r\n    assert(startResult.chat_id === chatId, 'Start should return correct chatId');\r\n    assert(startResult.text.includes('BETRIX'), 'Start should include BETRIX header');\r\n    assert(startResult.reply_markup, 'Start should include keyboard');\r\n    testResults.push({ test: '/start', status: 'Γ£à PASS' });\r\n    console.log('Γ£à PASS: /start works correctly\\n');\r\n\r\n    // Test 2: /menu command\r\n    console.log('≡ƒôî Test 2: /menu command');\r\n    const menuResult = await handleCommand('/menu', chatId, userId, redis, mockServices);\r\n    assert(menuResult.chat_id === chatId, 'Menu should return correct chatId');\r\n    assert(menuResult.reply_markup.inline_keyboard.length > 0, 'Menu should have buttons');\r\n    testResults.push({ test: '/menu', status: 'Γ£à PASS' });\r\n    console.log('Γ£à PASS: /menu works correctly\\n');\r\n\r\n    // Test 3: /help command\r\n    console.log('≡ƒôî Test 3: /help command');\r\n    const helpResult = await handleCommand('/help', chatId, userId, redis, mockServices);\r\n    assert(helpResult.chat_id === chatId, 'Help should return correct chatId');\r\n    assert(helpResult.text.includes('How to use'), 'Help should have usage info');\r\n    assert(helpResult.reply_markup.inline_keyboard, 'Help should have buttons');\r\n    testResults.push({ test: '/help', status: 'Γ£à PASS' });\r\n    console.log('Γ£à PASS: /help works correctly\\n');\r\n\r\n    // Test 4: /pricing command\r\n    console.log('≡ƒôî Test 4: /pricing command');\r\n    const pricingResult = await handleCommand('/pricing', chatId, userId, redis, mockServices);\r\n    assert(pricingResult.chat_id === chatId, 'Pricing should return correct chatId');\r\n    assert(pricingResult.text.includes('Free Tier'), 'Pricing should list tiers');\r\n    assert(pricingResult.text.includes('KES'), 'Pricing should show currency');\r\n    testResults.push({ test: '/pricing', status: 'Γ£à PASS' });\r\n    console.log('Γ£à PASS: /pricing works correctly\\n');\r\n\r\n    // Test 5: /vvip command\r\n    console.log('≡ƒôî Test 5: /vvip command');\r\n    const vvipResult = await handleCommand('/vvip', chatId, userId, redis, mockServices);\r\n    assert(vvipResult.chat_id === chatId, 'VVIP should return correct chatId');\r\n    assert(vvipResult.text.includes('Upgrade'), 'VVIP should mention upgrade');\r\n    assert(vvipResult.reply_markup.inline_keyboard, 'VVIP should have payment buttons');\r\n    testResults.push({ test: '/vvip', status: 'Γ£à PASS' });\r\n    console.log('Γ£à PASS: /vvip works correctly\\n');\r\n\r\n    // Test 6: /profile command\r\n    console.log('≡ƒôî Test 6: /profile command');\r\n    const profileResult = await handleCommand('/profile', chatId, userId, redis, mockServices);\r\n    assert(profileResult.chat_id === chatId, 'Profile should return correct chatId');\r\n    assert(profileResult.text.includes('Profile'), 'Profile should have profile content');\r\n    assert(profileResult.reply_markup.inline_keyboard, 'Profile should have buttons');\r\n    testResults.push({ test: '/profile', status: 'Γ£à PASS' });\r\n    console.log('Γ£à PASS: /profile works correctly\\n');\r\n\r\n    // Test 7: /live command\r\n    console.log('≡ƒôî Test 7: /live command');\r\n    const liveResult = await handleCommand('/live', chatId, userId, redis, mockServices);\r\n    assert(liveResult.chat_id === chatId, 'Live should return correct chatId');\r\n    assert(liveResult.text.includes('matches'), 'Live should mention matches');\r\n    testResults.push({ test: '/live', status: 'Γ£à PASS' });\r\n    console.log('Γ£à PASS: /live works correctly\\n');\r\n\r\n    // Test 8: /standings command\r\n    console.log('≡ƒôî Test 8: /standings command');\r\n    const standingsResult = await handleCommand('/standings', chatId, userId, redis, mockServices);\r\n    assert(standingsResult.chat_id === chatId, 'Standings should return correct chatId');\r\n    testResults.push({ test: '/standings', status: 'Γ£à PASS' });\r\n    console.log('Γ£à PASS: /standings works correctly\\n');\r\n\r\n    // Test 9: /news command\r\n    console.log('≡ƒôî Test 9: /news command');\r\n    const newsResult = await handleCommand('/news', chatId, userId, redis, mockServices);\r\n    assert(newsResult.chat_id === chatId, 'News should return correct chatId');\r\n    testResults.push({ test: '/news', status: 'Γ£à PASS' });\r\n    console.log('Γ£à PASS: /news works correctly\\n');\r\n\r\n    // Test 10: /odds command\r\n    console.log('≡ƒôî Test 10: /odds command');\r\n    const oddsResult = await handleCommand('/odds', chatId, userId, redis, mockServices);\r\n    assert(oddsResult.chat_id === chatId, 'Odds should return correct chatId');\r\n    testResults.push({ test: '/odds', status: 'Γ£à PASS' });\r\n    console.log('Γ£à PASS: /odds works correctly\\n');\r\n\r\n    // Test 11: Unknown command\r\n    console.log('≡ƒôî Test 11: Unknown command');\r\n    const unknownResult = await handleCommand('/unknown', chatId, userId, redis, mockServices);\r\n    assert(unknownResult.text.includes('not found') || unknownResult.text.includes('not recognized'), 'Should handle unknown commands');\r\n    testResults.push({ test: 'Unknown command', status: 'Γ£à PASS' });\r\n    console.log('Γ£à PASS: Unknown command handled correctly\\n');\r\n\r\n    // Test 12: menu_main callback\r\n    console.log('≡ƒôî Test 12: menu_main callback');\r\n    const menuCallbackResult = await handleCallback('menu_main', chatId, userId, redis, mockServices);\r\n    assert(menuCallbackResult.chat_id === chatId, 'Menu callback should return correct chatId');\r\n    assert(menuCallbackResult.reply_markup.inline_keyboard, 'Menu callback should have buttons');\r\n    testResults.push({ test: 'menu_main callback', status: 'Γ£à PASS' });\r\n    console.log('Γ£à PASS: menu_main callback works\\n');\r\n\r\n    // Test 13: menu_vvip callback\r\n    console.log('≡ƒôî Test 13: menu_vvip callback');\r\n    const vvipCallbackResult = await handleCallback('menu_vvip', chatId, userId, redis, mockServices);\r\n    assert(vvipCallbackResult.chat_id === chatId, 'VVIP callback should return correct chatId');\r\n    assert(vvipCallbackResult.text.includes('Premium'), 'VVIP callback should mention premium');\r\n    testResults.push({ test: 'menu_vvip callback', status: 'Γ£à PASS' });\r\n    console.log('Γ£à PASS: menu_vvip callback works\\n');\r\n\r\n    // Test 14: sub_vvip callback\r\n    console.log('≡ƒôî Test 14: sub_vvip callback');\r\n    const subCallbackResult = await handleCallback('sub_vvip', chatId, userId, redis, mockServices);\r\n    assert(subCallbackResult.chat_id === chatId, 'Sub callback should return correct chatId');\r\n    assert(subCallbackResult.text.includes('VVIP'), 'Sub callback should mention tier');\r\n    testResults.push({ test: 'sub_vvip callback', status: 'Γ£à PASS' });\r\n    console.log('Γ£à PASS: sub_vvip callback works\\n');\r\n\r\n    // Test 15: profile_stats callback\r\n    console.log('≡ƒôî Test 15: profile_stats callback');\r\n    const profileCallbackResult = await handleCallback('profile_stats', chatId, userId, redis, mockServices);\r\n    assert(profileCallbackResult.chat_id === chatId, 'Profile callback should return correct chatId');\r\n    assert(profileCallbackResult.text.includes('Stats'), 'Profile callback should show stats');\r\n    testResults.push({ test: 'profile_stats callback', status: 'Γ£à PASS' });\r\n    console.log('Γ£à PASS: profile_stats callback works\\n');\r\n\r\n    // Summary\r\n    console.log('\\n' + '='.repeat(50));\r\n    console.log('≡ƒôè TEST SUMMARY');\r\n    console.log('='.repeat(50));\r\n    console.log(`\\nTotal Tests: ${testResults.length}`);\r\n    console.log(`Passed: ${testResults.filter(r => r.status.includes('PASS')).length}`);\r\n    console.log(`Failed: ${testResults.filter(r => r.status.includes('FAIL')).length}\\n`);\r\n\r\n    testResults.forEach(r => {\r\n      console.log(`${r.status} - ${r.test}`);\r\n    });\r\n\r\n    console.log('\\nΓ£à All tests passed! Bot is ready for deployment.\\n');\r\n    process.exit(0);\r\n  } catch (err) {\r\n    console.error('\\nΓ¥î Test suite failed:');\r\n    console.error(err.message);\r\n    console.error(err.stack);\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nrunTests();\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\betrix-ui (1)\\betrix-ui\\tests\\v3-handlers.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
